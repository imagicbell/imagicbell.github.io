{"pageProps":{"post":{"title":"Serialization For Dynamically Created MonoBebavior Scripts","date":"2017-11-08T20:30:00+08:00","slug":"2017-11-8-unity-script-manipulation","categories":["Unity"],"readTime":2,"content":"<p>在Unity项目开发过程中，特别是UI开发，我们会做一些Automation Work，提高开发效率。比如我们做了一个标记UI Element并自动生成脚本获取的功能，操作步骤如下：</p>\n<ol>\n<li>在制作UI Prefab时，在挂载UI Element（Button, Image, InputField…）的GameObject上挂载<strong>UIMark</strong> MonoBehavior Script；</li>\n<li>制作完成后，自动生成（增量式）对应每个Prefab的<strong>UIComponents</strong> &nbsp;MonoBehavior Script，并为该Prefab下所有标记过<strong>UIMark</strong>的GameObject生成对应的成员变量，并且记录获取路径；</li>\n<li>UI逻辑代码可以直接通过<strong>UIComponents</strong>的成员变量获取所需的UI Element；</li>\n</ol>\n<p>看到这里，对性能有要求的同学是不是觉得有些问题？</p>\n<p>是的，在第2步结尾，只记录<em>获取路径</em>，意味着运行时会有一次查找操作<code>Transform.Find(relativePath)</code>，才能得到目标UI GameObject，并且也并没有做到即用即取，是在<code>Awake()</code>时一起查找的，这无疑增加了Instantiate过程的时间。</p>\n<p>于是，我采用Serialization来解决这个问题，将以上第2步结尾改为：</p>\n<p><em>在Editor模式下，直接将UI Element序列化给对应的成员变量。</em></p>\n<p><strong>But</strong>，这看似很简单的task，在实现过程中却有一个棘手的问题：</p>\n<p><em>UIComponent脚本是动态生成的，需要编译之后才能进行序列化操作，而<strong>动态生成脚本-&gt;编译-&gt;序列化</strong>这三步，我们要求是<strong>Done By One Click</strong>，如何做到？</em></p>\n<h3 id=\"section-解决方案\">解决方案</h3>\n<p>其实问题的根本，在于中间的编译环节，如何启动编译，以及如何获得编辑结束的回调？</p>\n<p>Fortunately，强大的Unity完美的提供了解决方案：</p>\n<ol>\n<li><p>有任意脚本改变时，Unity会自动编译；</p></li>\n<li><p>Unity Editor提供了一个定义回调的<a href=\"https://docs.unity3d.com/ScriptReference/Callbacks.DidReloadScripts.html\" rel=\"noopener noreferrer\" target=\"_blank\">方法</a>:</p></li>\n</ol>\n<pre><code class=\"c# language-c#\">   [UnityEditor.Callbacks.DidReloadScripts]\n   private static void CallbackMethod() { }</code></pre>\n<p>好了，问题解决了一大半。剩下来还有一个问题：</p>\n<p><em>编译过程是异步的，因此如何连接上下文？</em></p>\n<p>换句话说：<em>任何脚本的改动都会引起编译，编译结束后都会有该回调，如何判断是否需要执行下一步？</em></p>\n<p>我利用了<code>EditorPrefs</code>：</p>\n<ol>\n<li>每次自动生成脚本后，我会将相关信息（该脚本所挂载的UI Prefab路径），增量记录在一个key值里；</li>\n<li>在编译结束后的回调中检查该key是否存在，如果存在，即对key值里保存的UI Prefab进行序列化操作。</li>\n</ol>\n<p>Done!!!</p>"},"postNav":{"previous":"/posts/2017-10-31-blockly-four","next":"/posts/2017-12-1-unity-image-manipulation"},"morePosts":[{"slug":"2018-6-10-chain-animation-on-wheels","title":"Automatic Chain's Animation On wheel Models","date":"2018-06-10T16:00:00+08:00","locale":"en","readTime":3,"excerpt":"<p>In last blog, I introduced the construction of the chains on wheels. This blog will tell the animation calculations. The...</p>"},{"slug":"2018-6-7-auto-draw-chain-on-wheels","title":"Automatic Chain's Construction On wheel Models","date":"2018-06-07T16:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-auto-draw-chain/3.jpg","readTime":2,"excerpt":"<p>Rencently I did have fun with a project which I'd like to share. It is to construct a chain automatically...</p>"},{"slug":"2018-3-31-thread-in-unity","title":"Use Thread In Unity","date":"2018-03-31T13:00:00+08:00","locale":"en","readTime":2,"excerpt":"<p>It's been a long time since my last blog, as I've recently spent plenty of time to save a dying...</p>"},{"slug":"2018-1-20-orthographic-camera-computing","title":"Restrict Object In Specified Screen Area Using Orthographic Camera","date":"2018-01-20T15:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-orthographic-camera/1.JPG","readTime":3,"excerpt":"<p>I’ve encountered a problem to adjust the position of orthographic camera for restricting 3D objects in the specified rectangle area...</p>"}]},"__N_SSG":true}