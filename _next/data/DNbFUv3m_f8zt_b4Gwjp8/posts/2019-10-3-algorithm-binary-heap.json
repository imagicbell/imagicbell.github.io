{"pageProps":{"post":{"title":"Algorithm Notes: Binary Heap","date":"2019-10-03T20:00:00+08:00","slug":"2019-10-3-algorithm-binary-heap","categories":["Algorithm"],"readTime":2,"content":"<h3 id=\"section-definition\">Definition</h3>\n<p>A Binary Heap is a complete Binary Tree. It is either a Min Heap, where parent node's value is less than or equal to its children's, or a Max Heap, where parent node's value is greater than or equal to it's children's. </p>\n<p>It is represented as an array, where</p>\n<ul>\n<li>the root node is at <code>Arr[0]</code>;</li>\n<li>for the <span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>i</mi><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">i^{th}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.849108em; vertical-align: 0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">i</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.849108em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">t</span><span class=\"mord mathdefault mtight\">h</span></span></span></span></span></span></span></span></span></span></span></span></span> node <code>Arr[i]</code>, <ul>\n<li><code>Arr[(i-1)/2]</code> returns its parent node;</li>\n<li><code>Arr[2*i+1]</code> returns its left child node;</li>\n<li><code>Arr[2*i+2]</code> returns its right child node;</li></ul></li>\n</ul>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-binary-heap/binaryheap.png\" alt=\"\"></p>\n<h3 id=\"section-operation\">Operation</h3>\n<h4 id=\"section-construction\">Construction</h4>\n<p>The fundamental idea of binary heap construction is that, ==starting from the last parent node util the root node, construct a heap for each with all its children, because each branch node and its children compose a heap==.</p>\n<p>Given the struct of the heap:</p>\n<pre><code class=\"c# language-c#\">class BinaryHeap {\n    int[] heap;\n  int heapSize;        //current number of elements in heap\n  int capacity;        //maximum size of the heap\n}</code></pre>\n<p>Conventionally, <code>heap[0]</code> will work as the storage for temporary data, so the real heap data will start from <code>heap[1]</code> to <code>heap[heapSize]</code>. </p>\n<pre><code class=\"c# language-c#\">void Construct() {    \n  for (int i = heapSize/2; i &gt; 0; i--) {\n    Heapify(i);\n  }\n}\n\nvoid Heapify(int start) {\n  heap[0] = heap[start];\n  int son = start*2;\n  while (son &lt;= heapSize) {\n    if (son &lt; heapSize &amp;&amp; heap[son] &lt; heap[son+1])\n      son++;\n    if (heap[0] &gt;= heap[son])\n      break;\n    heap[son/2] = heap[son];\n    son *=2;\n  }\n  heap[son/2] = heap[0];\n}</code></pre>\n<p>As we see, we extract a method called <code>Heapify</code>, which is a core function in binary heap. It is used for maintaining the property of the subtree with given root.</p>\n<p>The following illustrates an example of the process:</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-binary-heap/0.png\" alt=\"\">        <img src=\"/blog/assets/img-binary-heap/1.png\" alt=\"\"></p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-binary-heap/2.png\" alt=\"\">        <img src=\"/blog/assets/img-binary-heap/3.png\" alt=\"\"></p>\n<p>The time complexity is <span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span style=\"margin-right: 0.02778em;\" class=\"mord mathdefault\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<h4 id=\"section-insert\">Insert</h4>\n<p>To insert an element into the heap, put the element at the end and then traverse up to fix the heap property, just like the construction process. The time complexity is <span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span style=\"margin-right: 0.02778em;\" class=\"mord mathdefault\">O</span><span class=\"mopen\">(</span><span style=\"margin-right: 0.01968em;\" class=\"mord mathdefault\">l</span><span class=\"mord mathdefault\">o</span><span style=\"margin-right: 0.03588em;\" class=\"mord mathdefault\">g</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<pre><code class=\"c# language-c#\">bool Insert(int x) {\n    if (heapSize == capacity)\n    return false;\n  int i = ++heapSize;\n  while (i &gt; 0 &amp;&amp; x &gt; heap[i/2]) {\n    heap[i] = heap[i/2];\n    i/=2;\n  }\n  heap[i] = x;\n  return true;\n}</code></pre>\n<h4 id=\"section-delete\">Delete</h4>\n<p>After removing the top element from the heap, place the last element at top, then fix the heap property. The time complexity is <span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span style=\"margin-right: 0.02778em;\" class=\"mord mathdefault\">O</span><span class=\"mopen\">(</span><span style=\"margin-right: 0.01968em;\" class=\"mord mathdefault\">l</span><span class=\"mord mathdefault\">o</span><span style=\"margin-right: 0.03588em;\" class=\"mord mathdefault\">g</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<pre><code class=\"c# language-c#\">int Delete() {\n  if (heapSize == 0) \n    return false;\n\n  int x = heap[1];\n  heapSize--;\n  Heapify(1);\n  return x;\n}</code></pre>\n<h3 id=\"section-application\">Application</h3>\n<h4 id=\"section-heap-sort\">Heap Sort</h4>\n<p>Using binary heap to sort an array takes <span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span style=\"margin-right: 0.02778em;\" class=\"mord mathdefault\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span style=\"margin-right: 0.01968em;\" class=\"mord mathdefault\">l</span><span class=\"mord mathdefault\">o</span><span style=\"margin-right: 0.03588em;\" class=\"mord mathdefault\">g</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></span> time. The idea is that extract the top element of the heap and put it at the end of the heap array, then fix the heap property.</p>\n<pre><code class=\"c# language-c#\">while(heapSize &gt; 0) {\n  int temp = heap[heapSize];\n  heap[heapSize] = heap[1];\n  heap[1] = temp;\n  heapSize--;\n  Heapify(1);\n}</code></pre>\n<h4 id=\"section-priority-queue\">Priority Queue</h4>\n<p>Binary Heap gives a maximum efficient implementation of priority queue. It provides the basic operation like insert, extract, peek priority value. Besides, it can do other more complicated operations, e.g. insert and extract a bunch of priority values(<a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\" rel=\"noopener noreferrer\" target=\"_blank\">leetcode</a>), change priority, merge multiple priority queues(<a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" rel=\"noopener noreferrer\" target=\"_blank\">leetcode</a>).</p>"},"postNav":{"previous":"/posts/2019-9-26-algorithm-kmp","next":"/posts/2020-7-10-algorithm-binary-search"},"morePosts":[{"slug":"2020-10-7-algorithm-traversal-of-binary-tree","title":"Algorithm Notes: Traversal of Binary Tree","date":"2020-10-07T16:00:00+08:00","locale":"en","readTime":3,"excerpt":"<p>Mostly we know that the traversal of binary tree can be easily done by recursion....</p>"},{"slug":"2020-7-10-algorithm-binary-search","title":"Algorithm Notes: Understanding of Binary Search","date":"2020-07-10T20:00:00+08:00","locale":"en","readTime":4,"excerpt":"<p>Recently, I have recovered my algorithm praticing. It's like something is messing in my mind, maybe due to the shallow...</p>"},{"slug":"2019-9-26-algorithm-kmp","title":"Algorithm Notes: KMP","date":"2019-09-26T20:00:00+08:00","locale":"en","readTime":10,"excerpt":"<p>String searching is one of the most common interview problems. Of course, it can be solved by using the simple...</p>"},{"slug":"2021-6-5-build-my-website-image-opti","title":"How To Build My Own Website (4) - Image Optimization","date":"2021-06-05T20:00:00+08:00","locale":"en","excerpt":"This article illustrates how I applied image optimization to improve the performance of my website.","readTime":0}]},"__N_SSG":true}