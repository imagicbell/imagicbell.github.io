{"pageProps":{"post":{"title":"Unity协程：解决嵌套IEnumerator导致多一帧的问题","date":"2017-10-30T15:00:00+08:00","slug":"2017-10-30-nested-ienumerator","description":"A solution to the problem that nested IEnumerator will cause Unity Couroutine to run one more frame.","categories":["Unity"],"readTime":5,"content":"<p>在Unity中，我们经常会用到Coroutine。利用C#语言提供的IEnumerator特性，它提供了很多便利：</p>\n<ul>\n<li>方便实现延时，<code>yield return new WaitForSeconds()</code>；</li>\n<li>方便实现异步，一个方法不限于在一帧内执行；</li>\n<li>方便实现重入，在一个方法的执行过程中可插入执行另一个方法，并等待执行结束后返回到当前方法的中断点继续执行。</li>\n</ul>\n<p>在此不加赘述使用方法，可参考<a href=\"https://docs.unity3d.com/Manual/Coroutines.html\" rel=\"noopener noreferrer\" target=\"_blank\">官方文档</a>，并且这里有一篇不错的<a href=\"https://www.alanzucconi.com/2017/02/15/nested-coroutines-in-unity/\" rel=\"noopener noreferrer\" target=\"_blank\">博文</a>。</p>\n<p>这里我主要介绍一下我在使用的过程中遇到的一个问题，以及解决办法。</p>\n<h3 id=\"section-why-one-more-frame\">Why One More Frame</h3>\n<p>下面看一个例子：</p>\n<p>测试代码</p>\n<pre><code class=\"c# language-c#\">IEnumerator Task1()\n{        \n    Debug.Log(\"&gt;&gt;&gt;Task1---1---\" + Time.time);\n    yield return Task2(false);\n\n    Debug.Log(\"&gt;&gt;&gt;Task1---2---\" + Time.time);\n    yield return Task2(true);\n\n    Debug.Log(\"&gt;&gt;&gt;Task1---3---\" + Time.time);\n}\n\nIEnumerator Task2(bool skip)\n{\n    Debug.Log(\"&gt;&gt;&gt;Task2---1---skip: \" + skip + \"  \" + Time.time);\n    if (!skip)\n        yield return 0;\n    Debug.Log(\"&gt;&gt;&gt;Task2---2---skip: \" + skip + \"  \" + Time.time);\n}\n\nIEnumerator Start () \n{\n    yield return new WaitForSeconds(1);\n    StartCoroutine(Task1());\n}</code></pre>\n<p>Log输出</p>\n<p><img src=\"/blog/assets/img-coroutine/Log1.png\" alt=\"\"></p>\n<p>从Log中可以看出，当<code>Task2</code>里没有执行任何<code>yield return</code>时，返回到<code>Task1</code>时仍然等了一帧往下执行。</p>\n<p>那么问题来了：是不是嵌套一次<code>yield return IEnumerator</code>就要至少花费一帧呢？我稍微改动了测试代码：</p>\n<pre><code class=\"c# language-c#\">IEnumerator Task1()\n{\n    Debug.Log(\"&gt;&gt;&gt;Task1---begin---\" + Time.time);\n    yield return Task2();\n    Debug.Log(\"&gt;&gt;&gt;Task1---end---\" + Time.time);\n}\nIEnumerator Task2()\n{\n    Debug.Log(\"&gt;&gt;&gt;Task2---1---\" + Time.time);\n    if (counter++ &lt; 3)\n        yield return Task2();\n    Debug.Log(\"&gt;&gt;&gt;Task2---2---\" + Time.time);\n}</code></pre>\n<p>Log输出</p>\n<p><img src=\"/blog/assets/img-coroutine/Log2.png\" alt=\"\"></p>\n<p>并没有！无论迭代嵌套多少次<code>Task2</code>都没有叠加一帧，而只是第一次返回调用点放在了下一帧执行。</p>\n<p>再次改动测试代码：</p>\n<pre><code class=\"c# language-c#\">IEnumerator Task1()\n{\n    Debug.Log(\"&gt;&gt;&gt;Task1---begin---\" + Time.time);\n    while (counter2++ &lt; 2)\n    {\n        counter = 0;\n        Debug.Log(\"&gt;&gt;&gt;Task1---1---\" + Time.time + \"---count2: \" + counter2);\n        yield return Task2();\n        Debug.Log(\"&gt;&gt;&gt;Task1---2---\" + Time.time + \"---count2: \" + counter2);\n    }    \n    Debug.Log(\"&gt;&gt;&gt;Task1---end---\" + Time.time);\n}\nIEnumerator Task2()\n{\n    Debug.Log(\"&gt;&gt;&gt;Task2---begin---\" + Time.time);\n    yield return Task3();\n    Debug.Log(\"&gt;&gt;&gt;Task2---end---\" + Time.time);\n}\nIEnumerator Task3()\n{\n    Debug.Log(\"&gt;&gt;&gt;Task3---begin---\" + Time.time+ \"---count: \" + counter);\n    if (counter++ &lt; 1)\n        yield return Task3();\n    Debug.Log(\"&gt;&gt;&gt;Task3---end---\" + Time.time+ \"---count: \" + counter);\n}</code></pre>\n<p>Log输出</p>\n<p><img src=\"/blog/assets/img-coroutine/Log3.png\" alt=\"\"></p>\n<p>可以看出，无论怎么深入、迭代嵌套下去，第一次返回调用点（yield return）总是在下一帧执行。这就带来了一个问题，当在最上层多次调用<code>yield return IEnumerator</code>，并且下层在嵌套调用时并没有真正执行<code>yield return Coroutine/YieldInstruction/null/value</code>时，就会多出不必要的帧，可能会导致与预期结果的偏差。我在<a href=\"/posts/2017-10-22-blockly-three\" rel=\"noopener noreferrer\" target=\"_blank\">实现Blockly Code Runner</a>时遇到了这个问题，因为采用了协程的方式执行Block的解释方法，但是一部分Block的解释方法是没有yield return的，理应执行完后立即执行下一个Block的方法，实际上却等了一帧。</p>\n<p>了解Coroutine执行原理的都知道，它是依赖于IEnumerator运作的，在Unity Monobehavior的一个生命周期中的某个时间点执行<code>MoveNext()</code>，返回<code>false</code>则结束。如果遇到嵌套IEnumerator调用，则应该是将其推入栈顶，先执行嵌套，等待执行完后推出。从这里可以推断出，推出后返回上一层IEnumerator后，需要在下一帧执行<code>MoveNext()</code>返回<code>false</code>才结束，因此才产生了这个问题。</p>\n<h3 id=\"section-solution\">Solution</h3>\n<p>鉴于以上反推出的可能原因，我修改了执行代码，在嵌套IEnumerator执行结束后立即推出并返回上一层，并且上一层立即执行<code>MoveNext()</code>，做到嵌套IEnumerator的推入、推出都是在一帧内连续的，只有在遇到除了IEnumerator外的yield return才等待。测试结果达到预期。</p>\n<pre><code class=\"c# language-c#\">IEnumerator SimulateCoroutine(IEnumerator itorFunc)\n{\n    Stack&lt;IEnumerator&gt; stack = new Stack&lt;IEnumerator&gt;();\n    stack.Push(itorFunc);\n    while (stack.Count &gt; 0)\n    {\n        IEnumerator itor = stack.Peek();\n        bool finished = true;\n        while (itor.MoveNext())\n        {\n            if (itor.Current is IEnumerator)\n            {\n                stack.Push((IEnumerator) itor.Current);\n                finished = false;\n                break;\n            }\n\n            yield return itor.Current;\n        }\n\n        if (finished)\n        {\n            stack.Pop();\n        }\n    }\n}</code></pre>\n<p>第三个测试代码Log输出</p>\n<p><img src=\"/blog/assets/img-coroutine/Log4.png\" alt=\"\"></p>\n<p>可能我的理解和推导不完全正确，如果错误，欢迎指出～</p>"},"postNav":{"previous":"/posts/2017-10-22-blockly-three","next":"/posts/2017-10-31-blockly-four"},"morePosts":[{"slug":"2018-6-10-chain-animation-on-wheels","title":"Automatic Chain's Animation On wheel Models","date":"2018-06-10T16:00:00+08:00","locale":"en","readTime":3,"excerpt":"<p>In last blog, I introduced the construction of the chains on wheels. This blog will tell the animation calculations. The...</p>"},{"slug":"2018-6-7-auto-draw-chain-on-wheels","title":"Automatic Chain's Construction On wheel Models","date":"2018-06-07T16:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-auto-draw-chain/3.jpg","readTime":2,"excerpt":"<p>Rencently I did have fun with a project which I'd like to share. It is to construct a chain automatically...</p>"},{"slug":"2018-3-31-thread-in-unity","title":"Use Thread In Unity","date":"2018-03-31T13:00:00+08:00","locale":"en","readTime":2,"excerpt":"<p>It's been a long time since my last blog, as I've recently spent plenty of time to save a dying...</p>"},{"slug":"2018-1-20-orthographic-camera-computing","title":"Restrict Object In Specified Screen Area Using Orthographic Camera","date":"2018-01-20T15:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-orthographic-camera/1.JPG","readTime":3,"excerpt":"<p>I’ve encountered a problem to adjust the position of orthographic camera for restricting 3D objects in the specified rectangle area...</p>"}]},"__N_SSG":true}