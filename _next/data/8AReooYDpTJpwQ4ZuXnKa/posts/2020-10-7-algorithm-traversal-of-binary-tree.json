{"pageProps":{"post":{"title":"Algorithm Notes: Traversal of Binary Tree","date":"2020-10-07T16:00:00+08:00","slug":"2020-10-7-algorithm-traversal-of-binary-tree","categories":["Algorithm"],"readTime":3,"content":"<p>Mostly we know that the traversal of binary tree can be easily done by recursion.</p>\n<h4 id=\"section-preorder\">Preorder</h4>\n<pre><code class=\"javascript language-javascript\">let result = [];\nfunction preorder(root) {\n  if (!root)\n    return;\n\n    result.push(root.val);\n  preorder(root.left);\n  preorder(root.right);\n}</code></pre>\n<h4 id=\"section-inorder\">Inorder</h4>\n<pre><code class=\"javascript language-javascript\">let result = [];\nfunction inorder(root) {\n  if (!root)\n    return;\n\n  inorder(root.left);\n  result.push(root.val);\n  inorder(root.right);\n}</code></pre>\n<h4 id=\"section-postorder\">Postorder</h4>\n<pre><code class=\"javascript language-javascript\">let result = [];\nfunction postorder(root) {\n  if (!root)\n    return;\n\n  postorder(root.left);\n  postorder(root.right);\n  result.push(root.val);\n}</code></pre>\n<h4 id=\"section-levelorder\">Levelorder</h4>\n<pre><code class=\"javascript language-javascript\">let result = [];\nfunction levelorder(root) {\n  let helper = nodes =&gt; {\n    let levelResult = [];\n    let newNodes = [];\n    nodes.forEach(node =&gt; {\n      if (node) {\n        levelResult.push(node.val);\n        newNodes.push(node.left);\n        newNodes.push(node.right);\n      }\n    });\n    result.push(levelResult);\n    helper(newNodes);\n  }\n\n  helper([root]);\n}    </code></pre>\n<p>The recursive traversal is quite straightforward and easily understood. However, we can also traverse the binary tree in an iterative way, which utilizes the stack.</p>\n<h4 id=\"section-preorder-1\">Preorder</h4>\n<p>The iteratice preorder traversal is the easiest, because it visits the parent node first, then the left tree, and then the right tree. So we push the right node into the stack first.</p>\n<pre><code class=\"javascript language-javascript\">function preorder(root) {\n  let result = [];\n  let stack = [root];\n  while (stack.length &gt; 0) {\n      let node = stack.pop();\n      if (node) {\n          result.push(node.val);\n          stack.push(node.right);\n          stack.push(node.left);    \n      }      \n  }\n  return result;\n}</code></pre>\n<h4 id=\"section-inorder-1\">Inorder</h4>\n<p>The iterative inorder traversal is a little more difficult. As we should traverse the leftmost child node first, so we iterate the left child util reaching the leaf. After that, we get the top node from the stack, which is the current needed node, and then push its right child into the stack. Then repeat.</p>\n<pre><code class=\"javascript language-javascript\">function inorder(root) {\n  let current = root;\n  let stack = [];\n  let results = [];\n  while (current || stack.length &gt; 0) {\n    while(current) {\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop();\n    results.push(current.val);\n    current = current.right;\n  }\n  return results;\n}</code></pre>\n<h4 id=\"section-postorder-1\">Postorder</h4>\n<p>The iterative postorder traversal is much more difficult for understanding and remembering. But there is a smart solution.</p>\n<ol>\n<li>Consider the preorder traversal: <strong>root -&gt; left -&gt; right</strong>.</li>\n<li>Then mirror the preorder traversal: <strong>root -&gt; right -&gt; left</strong>.</li>\n<li>Then reverse the mirror of the preorder traversal: <strong>left -&gt; right -&gt; root</strong>,  which is exactly the postorder traversal.</li>\n</ol>\n<pre><code class=\"javascript language-javascript\">function postorder(root) {\n  let stack = [root];\n  let result = [];\n  while (stack.length &gt; 0) {\n      let node = stack.pop();\n      if (node) {\n          result.unshift(node.val);\n          stack.push(node.left);\n          stack.push(node.right);\n      }\n  }\n  return result;\n}</code></pre>\n<h4 id=\"section-levelorder-1\">Levelorder</h4>\n<p>The iterative levelorder traversal is quite straightforward, which is just how the BFS does using Queue.</p>\n<pre><code class=\"javascript language-javascript\">function levelorder(root) {\n  let result = [];\n  let curQueue = [root];\n  while (curQueue.length &gt; 0) {\n      let tempQueue = [];\n      let levelResult = [];\n      curQueue.forEach(node =&gt; {\n         if (node) {\n             levelResult.push(node.val);\n             tempQueue.push(node.left);\n             tempQueue.push(node.right);\n         } \n      });\n      curQueue = tempQueue;\n      if (levelResult.length &gt; 0)\n          result.push(levelResult);\n  }\n  return result;\n}</code></pre>\n<h3 id=\"section-usage\">Usage</h3>\n<p>So why use the iterative traversal. When do we need to convert recursion to iteration.</p>\n<ol>\n<li>Recursive function call consumes additional memory on system stack, which may lead to stackoverflow. </li>\n<li>Iteration is more controllable. Think of implementing a iterator for the binary tree in whatever order. We can just <strong>yield</strong> the node in the iteration loop, or we can utilize the stack and control the returned node each time.</li>\n</ol>\n<p>In conclusion, iteration is an very efficient way to traverse the binary tree, although it is not that intuitive as the recursion does. However, we can keep in mind of an alternative solution.</p>"},"postNav":{"previous":"/posts/2020-8-28-ielts-7_5","next":"/posts/2021-1-7-rythm-game"},"morePosts":[{"slug":"2020-7-10-algorithm-binary-search","title":"Algorithm Notes: Understanding of Binary Search","date":"2020-07-10T20:00:00+08:00","locale":"en","readTime":4,"excerpt":"<p>Recently, I have recovered my algorithm praticing. It's like something is messing in my mind, maybe due to the shallow...</p>"},{"slug":"2019-10-3-algorithm-binary-heap","title":"Algorithm Notes: Binary Heap","date":"2019-10-03T20:00:00+08:00","locale":"en","readTime":2,"excerpt":"<p>A Binary Heap is a complete Binary Tree. It is either a Min Heap, where parent node's value is less...</p>"},{"slug":"2019-9-26-algorithm-kmp","title":"Algorithm Notes: KMP","date":"2019-09-26T20:00:00+08:00","locale":"en","readTime":10,"excerpt":"<p>String searching is one of the most common interview problems. Of course, it can be solved by using the simple...</p>"},{"slug":"2021-6-5-build-my-website-image-opti","title":"How To Build My Own Website (4) - Image Optimization","date":"2021-06-05T20:00:00+08:00","locale":"en","excerpt":"This article illustrates how I applied image optimization to improve the performance of my website.","readTime":0}]},"__N_SSG":true}