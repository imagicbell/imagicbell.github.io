{"pageProps":{"post":{"title":"The UGUI Design of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-13T20:00:00+08:00","slug":"2021-6-13-ublockly-ugui","ogImage":"/blog/assets/img-blockly/Demo.png","categories":["Unity"],"readTime":5,"content":"<h2 id=\"section-contents\">Contents</h2>\n<ol>\n<li><a href=\"/posts/2021-6-10-ublockly-introduction\" rel=\"noopener noreferrer\" target=\"_blank\">Introduction</a></li>\n<li><a href=\"/posts/2021-6-11-ublockly-model\" rel=\"noopener noreferrer\" target=\"_blank\">Blockly Model</a></li>\n<li><a href=\"/posts/2021-6-12-ublockly-interpreter-runner\" rel=\"noopener noreferrer\" target=\"_blank\">Code Interpreter and Runner</a></li>\n<li>UGUI Design</li>\n</ol>\n<p>For Chinese:</p>\n<ol>\n<li><a href=\"/posts/2017-10-11-blockly-one\" rel=\"noopener noreferrer\" target=\"_blank\">Introduction</a></li>\n<li><a href=\"/posts/2017-10-14-blockly-two\" rel=\"noopener noreferrer\" target=\"_blank\">Blockly Model</a></li>\n<li><a href=\"/posts/2017-10-22-blockly-three\" rel=\"noopener noreferrer\" target=\"_blank\">Code Interpreter and Runner</a></li>\n<li><a href=\"/posts/2017-10-31-blockly-four\" rel=\"noopener noreferrer\" target=\"_blank\">UGUI Design</a></li>\n</ol>\n<p><br></p>\n<p>UBlockly UI is a solution to the following problems:</p>\n<ul>\n<li><strong>Automatic block generation</strong>. The blocks can be automatically generated into prefabs in advance in Editor, or into gameObjects dynamically in run mode.  </li>\n<li><strong>Dynamic layout</strong>. The layout of the workspace can be dynamically adjusted after adding, moving, deleting, and changing blocks.</li>\n<li><strong>Adjusted block background</strong>. The background of blocks can be dynamically adjusted after changing the size or contents of the blocks.</li>\n<li><strong>Modularization</strong>. The UI module is separated from the core logic module, as mentioned <a href=\"/posts/2021-6-10-ublockly-introduction/#section-modularization\" rel=\"noopener noreferrer\" target=\"_blank\">here</a>, by applying observer design pattern.</li>\n<li><strong>Automatic snap</strong>. Search the nearest connectable block, and then snap automatically.</li>\n<li><strong>Workspace reconstruction</strong>. The workspace can be serialized into an XML file(<a href=\"/posts/2021-6-11-ublockly-model/#section-workspace\" rel=\"noopener noreferrer\" target=\"_blank\">#</a>). Also the workspace can be reconstructed from that XML file.</li>\n</ul>\n<h2 id=\"section-hierarchy-of-block-view\">Hierarchy of Block View</h2>\n<p>First we need a block view with the hierarchy not only adapting to the <a href=\"/posts/2021-6-11-ublockly-model/section-block\" rel=\"noopener noreferrer\" target=\"_blank\">block model structure</a>, but also working with the UGUI Transform Hierarchy to calculate the dynamic layout.</p>\n<pre><code>hierarchy of view:\n\n- Block\n  - ConnectionOutput\n  - ConnectionPrev  \n  - ConnectionNext\n    - Block(Next)\n\n  - LineGroup\n    - Input\n      - Field \n      - Field \n      ...\n      - ConnectionInput\n        - Block(Input)\n    - Input\n      ...\n  - LineGroup\n    ...\n  ...\n- Block\n  ... </code></pre>\n<p>Compared to the structure of block model, we add  <code>LineGroup</code> inside the block view. Because there might be more than one line in a block, it is better to use a container for layout calculation.</p>\n<h4 id=\"section-abstract-baseview\">Abstract BaseView</h4>\n<p>Every element in the above hierarchy is a <em>view</em>. The <em>view</em> should:</p>\n<ul>\n<li><p>have basic UGUI transform behaviors. </p>\n<p><em>It is inherited from <code>MonoBehavior</code>.</em></p></li>\n<li><p>have <em>Chainable Structure</em>, in order to facilitate iterative traversal among blocks in a workspace. </p>\n<p><em>It has <code>Parent</code>,  <code>Childs</code>, <code>Previous</code>, <code>Next</code>.</em></p></li>\n<li><p>be able to calculate the appearance dynamically, including the size for layout calculation and the background mesh.</p></li>\n</ul>\n<h4 id=\"section-all-views\">All Views</h4>\n<p>There are 6 views in all.</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Layout_9.png\" alt=\"\"></p>\n<p>The <em>Connection View</em> inside the <em>Input View</em> is implemented as <code>ConnectionInputView</code>. It is inherited from <code>ConnectionView</code>, which is inside a <em>Block View</em>. Apart from the basic connection behaviors, the <code>ConnectionInputView</code> also behaves like a slot, caring about the size of input blocks.</p>\n<h2 id=\"section-automatic-block-generation\">Automatic Block Generation</h2>\n<p>Based on the structure of Block Model, a block view can be built as the hierarchy mentioned above. The building order is from top to bottom:</p>\n<p><em>Block</em> -&gt; <em>Connection, LineGroup</em> -&gt; <em>Input</em> -&gt; <em>Field</em> </p>\n<p>The chainable structure is also taken into account. All the info can be serialized by <code>Monobehavior</code> into prefabs.</p>\n<h2 id=\"section-dynamic-layout\">Dynamic Layout</h2>\n<p>What is <strong>Dynamic Layout</strong> actually doing? Let's first see two examples:</p>\n<p><a href=\"/blog/assets/img-blockly/Layout_1.png\" rel=\"noopener noreferrer\" target=\"_blank\">Before</a> -&gt; <img loading=\"lazy\" src=\"/blog/assets/img-blockly/Layout_2.png\" alt=\"After\"></p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Layout_3.png\" alt=\"Before\"> -&gt; <img src=\"/blog/assets/img-blockly/Layout_4.png\" alt=\"After\"></p>\n<p>We can see that</p>\n<ol>\n<li>The size of blocks is changable to adjust the size of the content inside.</li>\n<li>The positions of each content inside a block and the connections between blocks are updated accordingly.</li>\n</ol>\n<p>As a result, it makes the layout of the workspace look natural and compact.</p>\n<p>We know that UGUI itself can calculate the layout automatically by appropriate settings of the <code>RectTransform</code>. But it does not work here, because we need a specific order to calculate the positions and sizes of each element based on the <em>Chainable Structure</em>.</p>\n<p>The order is <em>From-Bottom-to-Top</em>. Remember we mentioned above in <a href=\"#section-abstract-baseview\">Abstract BaseView</a>, that every element is a view and the view has <em>Chainable Structure</em>. Thus here we forget about whether it is a block, or an input, or a field. They are all views with positions, sizes, parents, childs, previous, and next. With the <em>Chainable Structure</em> we iteratively update the positions and sizes of all elements that are affected util reaching the root element.</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Layout_10.png\" alt=\"\"></p>\n<pre><code>public void UpdateLayout(Vector2 startPos)\n{\n    XY = startPos;\n    Size = CalculateSize();\n\n    switch (Type)\n    {\n        case ViewType.Field:\n        case ViewType.Input:\n        case ViewType.ConnectionInput:\n        case ViewType.LineGroup:\n        {\n            if (m_Next == null /*|| (!changePos &amp;&amp; !changeSize)*/)\n            {\n                //reach the last child, or no change in current hierarchy, update it's parent view\n                m_Parent.UpdateLayout(m_Parent.SiblingIndex == 0 ? m_Parent.HeaderXY : m_Parent.XY);\n            }\n            else\n            {\n                //update next\n                if (Type != ViewType.LineGroup)\n                {\n                    // same line\n                    startPos.x += Size.x + BlockViewSettings.Get().ContentSpace.x;\n                }\n                else\n                {\n                    // start a new line\n                    startPos.y -= Size.y + BlockViewSettings.Get().ContentSpace.y;\n                }\n\n                BaseView topmostChild = m_Next.GetTopmostChild();\n                if (topmostChild != m_Next)\n                {\n                    //need to update from its topmost child\n                    m_Next.XY = startPos;\n                    topmostChild.UpdateLayout(topmostChild.HeaderXY);\n                }\n                else\n                {\n                    m_Next.UpdateLayout(startPos);\n                }\n            }\n            break;\n        }\n        case ViewType.Connection:\n        case ViewType.Block:\n        {\n            //no need to update its m_Next, as it is handled by Unity's Transform autolayout \n            //update its parent directly\n            if (m_Parent != null)\n            {\n                m_Parent.UpdateLayout(m_Parent.SiblingIndex == 0 ? m_Parent.HeaderXY : m_Parent.XY);\n            }\n            break;\n        }\n    }\n}</code></pre>\n<h2 id=\"section-adjusted-background\">Adjusted Background</h2>\n<p>After the block views are dynamically layouted, their background should be re-rendered to fit the content as well. It relies on a technique called <a href=\"https://docs.unity3d.com/Manual/9SliceSprites.html\" rel=\"noopener noreferrer\" target=\"_blank\">9-slicing</a>. </p>\n<p>However, the default 9-slicing method does not work here. Let's first see an example:</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Layout_5.png\" alt=\"\"></p>\n<p>We only need one raw image to render above backgrounds.</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Layout_6.png\" alt=\"\"></p>\n<p>The solution is pretty simple. We override the function <code>OnPopulateMesh(VertexHelper)</code> in UGUI <code>Image</code>. In this function, we calculate vertices and uvs for each 9-slicing. <a href=\"/posts/2017-12-1-unity-image-manipulation\" rel=\"noopener noreferrer\" target=\"_blank\">This article</a> gives details on the implementationã€‚</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Layout_7.png\" alt=\"\">  -&gt;  <img src=\"/blog/assets/img-blockly/Layout_8.png\" alt=\"\"></p>\n<p>This solution has following pros:</p>\n<ul>\n<li>save resources.</li>\n<li>reduce drawcalls.</li>\n</ul>\n<h2 id=\"section-observer-pattern\">Observer Pattern</h2>\n<p>Observer design pattern is a common technique to facilitate the communication between models and views. We will save words on the details here.</p>\n<h2 id=\"section-binary-search-nearest\">Binary Search Nearest</h2>\n<p>When dragging a block, we provide the ability to automatically snap the block to the nearest connectable block. This involves the search algorithm. A straightforward search algorithm is to traverse all connection  points one by one. It takes time <span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span style=\"margin-right: 0.02778em;\" class=\"mord mathdefault\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></span>, which is obviously of not good performance. Google Blockly came out with a more optimal algorithm, <em>binary search</em>.</p>\n<p>One primary condition of binary search is that the sequence is ordered. Thus we need to order all the connection points in advance. The solution is:</p>\n<ol>\n<li><p>Connection points are ordered only by <code>y</code> coordinates. This means that connection points with same <code>y</code> are put together.</p></li>\n<li><p>Each time a connection is added or changed, we use binary search to find the appropriate position in the array for this connection.</p></li>\n<li><p>To search the nearest connection, we use binary search to find a position in the array, and then search forwards and backwards from that position util beyond the range for the shortest distance. In this process, the compatibility between connections are also taken into account.</p></li>\n</ol>\n<p>The time complexity is <span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span style=\"margin-right: 0.02778em;\" class=\"mord mathdefault\">O</span><span class=\"mopen\">(</span><span style=\"margin-right: 0.01968em;\" class=\"mord mathdefault\">l</span><span class=\"mord mathdefault\">o</span><span style=\"margin-right: 0.03588em;\" class=\"mord mathdefault\">g</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></span>. In the meantime, the amount of distance calculation is largely reduced.</p>\n<h2 id=\"section-workspace-reconstruction\">Workspace Reconstruction</h2>\n<p>The features of automatic block generation and dynamic layout facilitate the workspace reconstruction from XML file. The process is:</p>\n<ol>\n<li>XML content is deserialized into a workspace. <em>Block Model</em>.</li>\n<li>Block views are generated from Block Models. From the topmost blocks of the workspace, generate block views iteratively until reaching the last one.</li>\n<li>Connect blocks based on the connection data, and use dynamic layout to calculate the final positions and sizes.</li>\n</ol>\n<p><br></p>\n<p>The entire UI solution is inspired by the flow design of HTML file. Technologies are mutually linkedðŸ˜„.</p>"},"postNav":{"previous":"/posts/2021-6-12-ublockly-interpreter-runner","next":"/posts/2021-7-7-react-usecontext-usereducer"},"morePosts":[{"slug":"2021-6-12-ublockly-interpreter-runner","title":"The Interpreter and Runner of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-12T11:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":6,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-11-ublockly-model","title":"The Blockly Model of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-11T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":4,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-10-ublockly-introduction","title":"Introduction of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-10T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":1,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2018-6-10-chain-animation-on-wheels","title":"Automatic Chain's Animation On wheel Models","date":"2018-06-10T16:00:00+08:00","locale":"en","readTime":3,"excerpt":"<p>In last blog, I introduced the construction of the chains on wheels. This blog will tell the animation calculations. The...</p>"}]},"__N_SSG":true}