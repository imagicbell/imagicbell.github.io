{"pageProps":{"post":{"title":"The Blockly Model of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-11T20:00:00+08:00","slug":"2021-6-11-ublockly-model","ogImage":"/blog/assets/img-blockly/Demo.png","categories":["Unity"],"readTime":4,"content":"<h2 id=\"section-contents\">Contents</h2>\n<ol>\n<li><a href=\"/posts/2021-6-10-ublockly-introduction\" rel=\"noopener noreferrer\" target=\"_blank\">Introduction</a></li>\n<li>Blockly Model</li>\n<li><a href=\"/posts/2021-6-12-ublockly-interpreter-runner\" rel=\"noopener noreferrer\" target=\"_blank\">Code Interpreter and Runner</a></li>\n<li><a href=\"/posts/2021-6-13-ublockly-ugui\" rel=\"noopener noreferrer\" target=\"_blank\">UGUI Design</a></li>\n</ol>\n<p>For Chinese:</p>\n<ol>\n<li><a href=\"/posts/2017-10-11-blockly-one\" rel=\"noopener noreferrer\" target=\"_blank\">Introduction</a></li>\n<li><a href=\"/posts/2017-10-14-blockly-two\" rel=\"noopener noreferrer\" target=\"_blank\">Blockly Model</a></li>\n<li><a href=\"/posts/2017-10-22-blockly-three\" rel=\"noopener noreferrer\" target=\"_blank\">Code Interpreter and Runner</a></li>\n<li><a href=\"/posts/2017-10-31-blockly-four\" rel=\"noopener noreferrer\" target=\"_blank\">UGUI Design</a></li>\n</ol>\n<p><br></p>\n<p>The Blockly Model is translated from Google Blockly. As showed <a href=\"/posts/2021-6-10-ublockly-introduction#section-modularization\" rel=\"noopener noreferrer\" target=\"_blank\">here</a>, the main models include: <code>Workspace</code>,<code>Variable</code>, <code>Block</code>, <code>Connection</code>, <code>Input</code>, <code>Field</code>.</p>\n<h4 id=\"section-workspace\">Workspace</h4>\n<p>A workspace is a container for blocks and variables.</p>\n<ul>\n<li>A workspace can contain multiple excutable programs made by blocks connecting one another. </li>\n<li>The variables are shared and consistent inside a workspace. </li>\n</ul>\n<p>A workspace can be serialized into an <strong>XML</strong> file. The process can be reversed.</p>\n<p>Code Runner starts from the top blocks of the workspace and executes the interpreter of each block in a depth-first manner.</p>\n<h4 id=\"section-variable\">Variable</h4>\n<p>Variables are global in a workspace. They are stored in a dictionary, where the key is a unique name for indexing and the value is the real value of that variable.</p>\n<h4 id=\"section-block\">Block</h4>\n<p>A block represents a piece of executable program.</p>\n<p>A block acts like a function. It can either have a return, which can be used as an input for another block, or no return, which can be executed after another block.</p>\n<p>Thus, the connections between blocks are defined as two: </p>\n<ul>\n<li>input/output</li>\n<li>previous/next</li>\n</ul>\n<p>The structure of a block is like this:</p>\n<pre><code>- Block(Topmost in workspace)\n  - ConnectionOutput\n  - ConnectionPrev\n  - ConnectionNext\n    - Block(Next)\n  - Input\n    - Field \n    - Field \n      ...\n    - ConnectionInput\n      - Block(Input)\n  - Input\n    ...\n- Block\n  ...\n- Block\n  ...</code></pre>\n<h4 id=\"section-connection\">Connection</h4>\n<p>The connection is how blocks are mutually connected.</p>\n<pre><code>  Block.ConnectionOutput &lt;-&gt; Block.Input.ConnectionInput\n  Block.ConnectionPrev &lt;-&gt; Block.ConnectionNext</code></pre>\n<h4 id=\"section-input\">Input</h4>\n<p>As shown in the above block structure, apart from connections, inputs are the elementary units that form a block. </p>\n<p>An input consists of multiple fields and a connection for the input block. </p>\n<p>If an input doesn't need to connect an input block, it is called <em>dummy input</em>.</p>\n<p>The inputs are built in the order defined in the <a href=\"#section-block-json-definition\">Block JSON Definition</a>. Let's see an example:</p>\n<pre><code>\"message0\": \"%{BKY_COROUTINE_WAIT_TITLE} %1 %2\",\n\"args0\": [\n  {\n    \"type\": \"input_value\",\n    \"name\": \"TIME\",\n    \"check\": \"Number\"\n  },\n  {\n    \"type\": \"field_dropdown\",\n    \"name\": \"UNIT\",\n    \"options\": [\n      [\"%{BKY_TIME_UNIT_MILLISECOND}\", \"MILLISECOND\"],\n      [\"%{BKY_TIME_UNIT_SECONDS}\", \"SECONDS\"],\n      [\"%{BKY_TIME_UNIT_MINUTES}\", \"MINUTES\"],\n      [\"%{BKY_TIME_UNIT_TOO_HIGH}\", \"TOOHIGH\"]\n    ]\n  }\n],</code></pre>\n<p>This block will be rendered as below:</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/JsonDef_1.png\" alt=\"\"></p>\n<p>The <code>message0</code> defines the shape of the block.</p>\n<ul>\n<li><code>%{BKY_COROUTINE_WAIT_TITLE}</code>: the key for multi-language translations.</li>\n<li><code>%1</code>: <code>input_value</code></li>\n<li><code>%2</code>: <code>field_dropdown</code></li>\n</ul>\n<p>So the block has two inputs:</p>\n<ol>\n<li><code>input_value</code> for an input block.</li>\n<li><em>dummy input</em>. Because the last <code>field_dropdown</code> has no input after it, we append a dummy input to hold this field.</li>\n</ol>\n<h4 id=\"section-field\">Field</h4>\n<p>Fields defind the properties or states of a block. In the above example, </p>\n<p><code>field_dropdown</code> provides a dropdown menu for selecting the time units.</p>\n<p>There are more fields, like <code>field_variable</code>, <code>field_number</code>, <code>field_textinput</code> and so on. More customized fields can be added.</p>\n<h2 id=\"section-block-json-definition\">Block JSON Definition</h2>\n<p>The format of a Block JSON Definition:</p>\n<pre><code>\"type\": \"[CategoryName]_[BlockName]\",\n\"message0\": [Message],\n\"args0\":[\n    {\n        \"type\": [Type]\n        \"name\": [Name]\n        \"message\": [ArgMessage]\n        \"check\": [Check]\n        \"variable\": [Variable]\n        \"options\": [Options]\n    },\n    ...\n],\n\"message1\": [Message]\n\"args1\":[\n      {\n        \"type\": [Type]\n        \"name\": [Name]\n        \"message\": [ArgMessage]\n        \"check\": [Check]\n        \"variable\": [Variable]\n        \"align\": [Align]\n        \"options\": [Options]\n    },\n    ...\n]\n....\n\"messageN: [Message],\n\"argsN\": [\n    ...\n],\n\"previousStatement\": [PreviousStament],\n\"nextStatement\": [NextStatement],\n\"output\": [Output],\n\"inputsInline\": [InputsInline],\n\"mutator\" :  [Mutator],\n\"colour\" : [Colour],</code></pre>\n<ul>\n<li><code>type</code>: the unique id for identifying a block. It follows the format <code>[CategoryName]_[BlockName]</code>.</li>\n<li><code>messageN</code>: defines the shape of a line in the block.</li>\n<li><code>argsN</code>: list the inputs and fields corresponding to <code>messageN</code>.</li>\n<li><code>previousStatement</code>:  whether it has a previous connection.</li>\n<li><code>nextStatement</code>: whether it has a next connection.</li>\n<li><code>output</code>: whether it returns a value, which means that it can act as an input block.</li>\n<li><code>inputsInline</code>: whether the inputs are aligned in one line. This is for UI display.</li>\n<li><code>mutator</code>: whether it has a <a href=\"#section-mutation\">mutation feature</a>. This feature will be explained later in this article.</li>\n</ul>\n<p>Here is an example:</p>\n<pre><code>\"type\": \"controls_whileUntil\",\n\"message0\": \"%1 %2\",\n\"args0\": [\n  {\n    \"type\": \"field_dropdown\",\n    \"name\": \"MODE\",\n    \"options\": [\n      [\"%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_WHILE}\", \"WHILE\"],\n      [\"%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_UNTIL}\", \"UNTIL\"]\n    ]\n  },\n  {\n    \"type\": \"input_value\",\n    \"name\": \"BOOL\",\n    \"check\": \"Boolean\"\n  }\n],\n\"message1\": \"%{BKY_CONTROLS_REPEAT_INPUT_DO} %1\",\n\"args1\": [{\n  \"type\": \"input_statement\",\n  \"name\": \"DO\"\n}],\n\"previousStatement\": null,\n\"nextStatement\": null,\n\"colour\": \"%{BKY_LOOPS_HUE}\",</code></pre>\n<p>It results:</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/JsonDef_2.png\" alt=\"\"></p>\n<p><a href=\"https://hackmd.io/@beBvDP44ShyK5VorFbhGcw/H1Qbb1HBu#Create-a-new-block\" rel=\"noopener noreferrer\" target=\"_blank\">This doc</a> provides a detailed explaination and instruction on the JSON definition.</p>\n<h2 id=\"section-mutation\">Mutation</h2>\n<p>First we see an example.</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Mutator_IfElse_1.png\" alt=\"\"></p>\n<p>This is a <code>if</code> condition program. What if we need a <code>if/else</code>, or <code>if/elseif/else</code>, <code>if/elseif/elseif/...../else</code>. Do we have to add a JSON definition for each? </p>\n<p>Obviously not. This is where <strong>mutation</strong> comes out.</p>\n<p>Let's see the JSON definition:</p>\n<pre><code>\"type\": \"controls_if\",\n\"message0\": \"%{BKY_CONTROLS_IF_MSG_IF} %1\",\n\"args0\": [\n  {\n    \"type\": \"input_value\",\n    \"name\": \"IF0\",\n    \"check\": \"Boolean\"\n  }\n],\n\"message1\": \"%{BKY_CONTROLS_IF_MSG_THEN} %1\",\n\"args1\": [\n  {\n    \"type\": \"input_statement\",\n    \"name\": \"DO0\"\n  }\n],\n\"previousStatement\": null,\n\"nextStatement\": null,\n\"colour\": \"%{BKY_LOGIC_HUE}\",\n\"mutator\": \"controls_if_mutator\",</code></pre>\n<p>We add a <code>mutator</code> which has a value <code>controls_if_mutator</code>. This is used to identify which mutation feature this block uses. We need to implement the behavior for each mutation feature. </p>\n<p>In our <code>controls_if_mutator</code>, we enable to configure how many <code>elseif</code> there is, and whether there is a <code>else</code>. Then the block will be mutated according to the configuration.</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Mutator_IfElse_3.png\" alt=\"\"></p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Mutator_IfElse_2.png\" alt=\"\"></p>\n<h3 id=\"section-procedurefunction\">Procedure(function)</h3>\n<p>Functions, which is called procedures in Google Blockly, are implemented based on mutation. A procedure is configured with a name and inputs.</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Mutator_Procedure_1.png\" alt=\"\"></p>\n<p>The above configuration produces a <code>swap</code> function, which has two arguments, <code>x</code> and <code>y</code>.</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-blockly/Procedure_1.png\" alt=\"\"></p>\n<p>There are two types of procedures: </p>\n<ul>\n<li><em>Procedure Definition</em>: use mutation to define the function.</li>\n<li><em>Procedure Call</em>: make a function call defined by <em>Procedure Definition</em>, passing in arguments. After configuring a <em>Procedure Definition</em>, a <em>Procedure Call</em> is produced in the <em>Toolbox</em>, which can be dragged out to make the function call.</li>\n</ul>\n<h3 id=\"section-customize-mutation\">Customize Mutation</h3>\n<p>More mutation features can be added by</p>\n<ol>\n<li><p>add the <code>mutator</code> property in the JSON definition.</p></li>\n<li><p>implement the mutator behavior (reference the existing mutators).</p></li>\n</ol>"},"postNav":{"previous":"/posts/2021-6-10-ublockly-introduction","next":"/posts/2021-6-12-ublockly-interpreter-runner"},"morePosts":[{"slug":"2021-6-13-ublockly-ugui","title":"The UGUI Design of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-13T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":5,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-12-ublockly-interpreter-runner","title":"The Interpreter and Runner of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-12T11:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":6,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-10-ublockly-introduction","title":"Introduction of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-10T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":1,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2018-6-10-chain-animation-on-wheels","title":"Automatic Chain's Animation On wheel Models","date":"2018-06-10T16:00:00+08:00","locale":"en","readTime":3,"excerpt":"<p>In last blog, I introduced the construction of the chains on wheels. This blog will tell the animation calculations. The...</p>"}]},"__N_SSG":true}