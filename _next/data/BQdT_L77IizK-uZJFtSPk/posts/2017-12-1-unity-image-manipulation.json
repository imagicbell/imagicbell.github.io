{"pageProps":{"post":{"title":"Manipulate UGUI Image Mesh","date":"2017-12-01T17:00:00+08:00","slug":"2017-12-1-unity-image-manipulation","description":"Override the Mesh implementation('OnPopulateMesh' method) in UnityEngine.UI.Image to manipulate customized images.","categories":["Unity"],"readTime":4,"content":"<p>It is known that the <code>Image</code> component in Unity UI can draw a texture under canvas. There are basically 4 types: Simple, Sliced, Tiled, Filled, which offers diversity manipulation of texture drawing. However, it is not enough! After digging into the source code of the implementations of those 4 drawing types, I found a way to customizing images.</p>\n<p>The following are two cases of customizing shape and offset:</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-uimage-manipulation/showcase1.png\" alt=\"\"></p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-uimage-manipulation/showcase2.png\" alt=\"\"></p>\n<p><em>left: raw image; right: customized image</em></p>\n<h3 id=\"section-how-to\">How To</h3>\n<p>Mesh is the key point. It carries the information of vertices, colors and uvs which will then be sent to GPU for rendering. So by manipulating the mesh, the goal will be achieved.</p>\n<p>In Unity UI, class <code>Graphic</code> is the base class for all visual UI components, and it offers an virtual method <code>OnPopulateMesh</code> for customizing the mesh construction. A typical simple graphic mesh is contructed by composing a rectangle:</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-uimage-manipulation/simple.png\" alt=\"\"></p>\n<p>The code is like this:</p>\n<pre><code class=\"c# language-c#\">//vertice 0\nvh.AddVert(new Vector3(vector4.x, vector4.y), color, new Vector2(0.0f, 0.0f));\n//vertice 1\nvh.AddVert(new Vector3(vector4.x, vector4.w), color, new Vector2(0.0f, 1f));\n//vertice 2\nvh.AddVert(new Vector3(vector4.z, vector4.w), color, new Vector2(1f, 1f));\n//vertice 3\nvh.AddVert(new Vector3(vector4.z, vector4.y), color, new Vector2(1f, 0.0f));\nvh.AddTriangle(0, 1, 2);\nvh.AddTriangle(2, 3, 0);</code></pre>\n<p><code>vector4</code> gives the x(min horizontal), y(min vertical), z(max horizontal), w(max vertical) values.</p>\n<p>Moreover, we can see the composition of a sliced image:</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-uimage-manipulation/sliced.png\" alt=\"\"></p>\n<p>There are 9 rectangles, and each of them are constructed by calculating the real vertices' positions and the sliced border positions and inner/outer uvs.</p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-uimage-manipulation/slicedtex.png\" alt=\"\"></p>\n<p>The code is a bit long. You can check the source code which is opened if interested.</p>\n<p>So here it is. Given the rectangles' dimension value, and adjust the corresponding uvs, will reform the images. The principle is easy, but the code is a bit tedious.</p>\n<pre><code class=\"c# language-c#\">protected override void OnPopulateMesh(VertexHelper toFill)\n{\n    //m_DrawDimensions is a vector4 array defining the retangles' dimensions to draw\n    if (m_DrawDimensions == null || m_DrawDimensions.Length == 0)\n    {\n        base.OnPopulateMesh(toFill);\n        return;\n    }\n\n    toFill.Clear();\n\n    Vector4 outerUV;\n    Vector4 innerUV;\n    Vector4 border;\n    if ((UnityEngine.Object) this.overrideSprite != (UnityEngine.Object) null)\n    {\n        outerUV = DataUtility.GetOuterUV(this.overrideSprite);\n        innerUV = DataUtility.GetInnerUV(this.overrideSprite);\n        border = this.overrideSprite.border / this.pixelsPerUnit;\n    }\n    else\n    {\n        outerUV = Vector4.zero;\n        innerUV = Vector4.zero;\n        border = Vector4.zero;\n    }\n\n    Rect pixelAdjustedRect = this.GetPixelAdjustedRect();\n    RectTransform rectTrans = GetComponent&lt;RectTransform&gt;();\n    float xFactor = pixelAdjustedRect.width / rectTrans.rect.width;\n    float yFactor = pixelAdjustedRect.height / rectTrans.rect.height;\n    Vector4 factor = new Vector4(xFactor, yFactor, xFactor, yFactor);\n\n    for (int i = 0; i &lt; m_DrawDimensions.Length; i++)\n    {\n        Vector4 dimension = m_DrawDimensions[i];\n        dimension.Scale(factor);\n\n        int xCount = 3;\n        int yCount;\n\n        mVert_X[0] = dimension.x;\n        mVert_X[1] = dimension.x + border.x;\n        mVert_X[2] = dimension.z - border.z;\n        mVert_X[3] = dimension.z;\n\n        mUV_X[0] = outerUV.x;\n        mUV_X[1] = innerUV.x;\n        mUV_X[2] = innerUV.z;\n        mUV_X[3] = outerUV.z;\n\n        if (m_DrawDimensions.Length == 1)\n        {\n            //9 quads\n            mVert_Y[0] = dimension.y;\n            mVert_Y[1] = dimension.y + border.y;\n            mVert_Y[2] = dimension.w - border.w;\n            mVert_Y[3] = dimension.w;\n\n            mUV_Y[0] = outerUV.y;\n            mUV_Y[1] = innerUV.y;\n            mUV_Y[2] = innerUV.w;\n            mUV_Y[3] = outerUV.w;\n\n            yCount = 3;\n        }\n        else\n        {\n            if (i == 0)\n            {\n                //6 quads\n                mVert_Y[0] = dimension.y;\n                mVert_Y[1] = dimension.w - border.w;\n                mVert_Y[2] = dimension.w;\n\n                mUV_Y[0] = innerUV.y;\n                mUV_Y[1] = innerUV.w;\n                mUV_Y[2] = outerUV.w;\n\n                yCount = 2;\n            }\n            else if (i == m_DrawDimensions.Length - 1)\n            {\n                //6 quads\n                mVert_Y[0] = dimension.y;\n                mVert_Y[1] = dimension.y + border.y;\n                mVert_Y[2] = dimension.w;\n\n                mUV_Y[0] = outerUV.y;\n                mUV_Y[1] = innerUV.y;\n                mUV_Y[2] = innerUV.w;\n\n                yCount = 2;\n            }\n            else\n            {\n                //3 quads\n                mVert_Y[0] = dimension.y;\n                mVert_Y[1] = dimension.w;\n\n                mUV_Y[0] = innerUV.y;\n                mUV_Y[1] = innerUV.w;\n\n                yCount = 1;\n            }\n        }\n\n        Vector4 dim, uv;\n        for (int yMin = 0; yMin &lt; yCount; yMin++)\n        {\n            int yMax = yMin + 1;\n            for (int xMin = 0; xMin &lt; xCount; xMin++)\n            {\n                int xMax = xMin + 1;\n                dim = new Vector4(mVert_X[xMin], mVert_Y[yMin], mVert_X[xMax], mVert_Y[yMax]);\n                uv = new Vector4(mUV_X[xMin], mUV_Y[yMin], mUV_X[xMax], mUV_Y[yMax]);\n                AddQuad(toFill, dim, uv);\n            }\n        }\n    }\n}\n\nprivate void AddQuad(VertexHelper vertexHelper, Vector4 pos, Vector4 uv)\n{\n    int currentVertCount = vertexHelper.currentVertCount;\n    Color32 c = (Color32) this.color;\n    vertexHelper.AddVert(new Vector3(pos.x, pos.y, 0.0f), c, new Vector2(uv.x, uv.y));\n    vertexHelper.AddVert(new Vector3(pos.x, pos.w, 0.0f), c, new Vector2(uv.x, uv.w));\n    vertexHelper.AddVert(new Vector3(pos.z, pos.w, 0.0f), c, new Vector2(uv.z, uv.w));\n    vertexHelper.AddVert(new Vector3(pos.z, pos.y, 0.0f), c, new Vector2(uv.z, uv.y));\n    vertexHelper.AddTriangle(currentVertCount, currentVertCount + 1, currentVertCount + 2);\n    vertexHelper.AddTriangle(currentVertCount + 2, currentVertCount + 3, currentVertCount);\n}</code></pre>\n<p>If anything got inpropriate here, please be open to discuss :)</p>"},"postNav":{"previous":"/posts/2017-11-8-unity-script-manipulation","next":"/posts/2018-1-2-essay-1"},"morePosts":[{"slug":"2021-6-13-ublockly-ugui","title":"The UGUI Design of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-13T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":5,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-12-ublockly-interpreter-runner","title":"The Interpreter and Runner of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-12T11:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":6,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-11-ublockly-model","title":"The Blockly Model of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-11T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":4,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-10-ublockly-introduction","title":"Introduction of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-10T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":1,"excerpt":"<p>For Chinese:...</p>"}]},"__N_SSG":true}