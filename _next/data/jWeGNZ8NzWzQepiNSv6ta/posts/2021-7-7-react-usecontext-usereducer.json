{"pageProps":{"post":{"title":"Use React Context + useReducer to Implement A Simple State Management Like Redux","date":"2021-07-07T20:00:00+08:00","slug":"2021-7-7-react-usecontext-usereducer","categories":["Front-End"],"readTime":4,"content":"<p>React Hooks have brought us much convenience in writing concise readable code. Recently, I have been enjoying the usage of React Context and useReducer to implement a simple state management architecture, as a replacement of Redux. There are at least two advantages here:</p>\n<ol>\n<li>The store code is much shorter.</li>\n<li>We could have more than one stores. Benefit from this, we can seperate unrelated data into different stores, avoiding unexpected re-renders of Components.</li>\n</ol>\n<h3 id=\"section-recap-of-redux\">Recap of Redux</h3>\n<p>Redux has introduced a simple data flow for React. </p>\n<p><img loading=\"lazy\" src=\"/blog/assets/img-react-redux/redux.jpg\" alt=\"\"></p>\n<p>From this chart we could see that the only two exploded data are <code>state</code> and <code>dispatch</code>. The components who use the state data for rendering need to <code>connect</code> the store for extracting the data. To update the state, <code>dispatch</code> an action with a pre-defined type and update data. Then the reducers in the store catch the action and update the state. Those components then get update as well.</p>\n<h3 id=\"section-the-power-of-context\">The Power of Context</h3>\n<p>After I got familar with the usage of Context, I found that Redux might have used Context to pass the store data to those child components. With context, we don't need to pass the data by props all the way down to the children. It works like a global singleton. A child component only needs to register as a <strong>Consumer</strong> to get the context data. There are several ways to be a consumer, see the <a href=\"https://reactjs.org/docs/context.html\" rel=\"noopener noreferrer\" target=\"_blank\">doc</a>.</p>\n<p>So in my design, I create a context as a store. Then <code>export</code> a context <code>Provider</code> for children components.</p>\n<pre><code class=\"jsx language-jsx\">const Store = createContext();\nStore.displayName = 'Store';\n\nexport function StoreProvider({children}) {\n    /* get the data */\n    return &lt;Store.Provider value={data}&gt;{children}&lt;/Store.Provider&gt;\n}</code></pre>\n<p>Attach the provider in the outmost component.</p>\n<pre><code class=\"jsx language-jsx\">function App() {\n  return (\n    &lt;StoreProvider&gt;\n        &lt;Home /&gt;\n    &lt;/StoreProvider&gt;\n  );\n}</code></pre>\n<p>A child functional component can use <code>useContext</code> to catch the data.</p>\n<pre><code class=\"jsx language-jsx\">function ChildComponent({props}) {\n  const data = useContext(Store);\n  /* then render with the data */\n}</code></pre>\n<p>However, importing <code>Store</code> in every component and calling <code>useContext</code> seem like duplicate code. We can define a <code>connect</code> HOC that takes in a component and returns a new component with the store data that is wanted.</p>\n<pre><code class=\"jsx language-jsx\">// connect HOC defined in the store.js\nexport function connect(Component, selector) {\n    return props =&gt; {\n        const ctx = selector(useContext(Store));\n        return &lt;Component {...{...props, ...ctx}} /&gt;;\n    }\n}\n\n// use connect in ChildComponentjs\nfunction ChildComponent({totalRestaurants}) {\n  /* general render code here */\n}\nexport default connect(ChildComponent, ({restaurants}) =&gt; ({totalRestaurants: restaurants}));</code></pre>\n<p>The <code>selector</code> is a function that selects what data the ChildComponent needs. The store value can be a big object. Child components may not need the whole object value.</p>\n<p>OK, this is the Context part. If we only have a static store, which doesn't update its state, it's sufficient. You can stop reading now. But if the store needs to update its state by actions, we prefer reducers. Keep reading please.</p>\n<h3 id=\"section-usereducer-to-update-store\"><code>useReducer</code> to Update Store</h3>\n<p>In our context store, we can use <code>useState</code> to update our store data, and then pass update function as callbacks to our child components for updating the store. But <code>useReducer</code> provides an alternative way. It is more useful when we have complex state logic, and more performant because it passes <code>dispatch</code> to child components rather than callbacks. </p>\n<pre><code class=\"jsx language-jsx\">const initialValue = [];\n\nexport const addItem = (id) =&gt; ({\n    type: 'ADD',\n    id,\n})\n\nconst reducer = (state, action) =&gt; {\n    switch(action.type) {\n        case 'ADD':\n            //do add logic, and return new state.\n        default:\n            return state;\n    }\n}\n\nexport function StoreProvider({children}) {\n  const [state, dispatch] = useReducer(reducer, initialValue, init);\n    return &lt;Store.Provider value={{state, dispatch}}&gt;{children}&lt;/Store.Provider&gt;\n}\n\n//then we use connect HOC as above to allow child components access the state and dispatch.\n\n//this is how child component connect to the store\n// use connect in ChildComponentjs\nfunction ChildComponent({favorites, onAdd}) {\n  /* general render code here */\n}\n\nexport default connect(ChildComponent, ({state, dispatch}) =&gt; ({\n    favorites: state,\n    onAdd: id =&gt; dispatch(addItem(id)),\n}));</code></pre>\n<p>Doesn't this <code>connect</code> syntatic sugar look familiar? I guess I am getting closer to ReduxðŸ˜„.</p>\n<h3 id=\"section-performance\">Performance</h3>\n<p>When reaching here, do you have a doubt regarding to the performance of this architecture. Any update in context's value will cause re-render to those context consumers. For example, a store context has an object value which has two properties:</p>\n<pre><code class=\"jsx language-jsx\">//context value\n{\n  a: 0,\n  b: 1\n}</code></pre>\n<p>Child component A only consumes <code>a</code>, while child componnet B only consumes <code>b</code>. If <code>a</code> is updated, not only componnet <code>A</code> will re-render, but also component <code>B</code>, because any update in context value will update all context consumers. So how to resolve this issue?</p>\n<p>I guess it is an classical React performance problem. React has provided several ways to prevent unexpected re-render. Regarding to this situation, we can use:</p>\n<ol>\n<li><code>React.memo</code> to only re-render functional component when its props changes.</li>\n<li><code>shouldComponentUpdate</code> to set condition on whether the component needs re-render.</li>\n<li>Pure component to implicitly execute <code>shouldComponentUpdate</code> to listen to the changes in state or props.</li>\n</ol>\n<h3 id=\"section-conclusion\">Conclusion</h3>\n<p>This architecture might be very flexible and light in small projects. But in big projects, Redux still has its position as it enables sub-stores which seperate state logic. Also the community has tons of middlewares which makes coding easier.</p>"},"postNav":{"previous":"/posts/2021-6-5-build-my-website-image-opti","next":null},"morePosts":[{"slug":"2021-6-5-build-my-website-image-opti","title":"How To Build My Own Website (4) - Image Optimization","date":"2021-06-05T20:00:00+08:00","locale":"en","excerpt":"This article illustrates how I applied image optimization to improve the performance of my website.","readTime":2},{"slug":"2021-3-14-build-my-website-style","title":"How To Build My Own Website (3) - Style","date":"2021-03-14T20:00:00+08:00","locale":"en","excerpt":"This article illustrates how I style my own website using Tailwindcss framework, make theme color configurable, and apply interactive animations.","readTime":2},{"slug":"2021-3-12-build-my-website-markdown","title":"How To Build My Own Website (2) - Markdown","date":"2021-03-12T20:00:00+08:00","locale":"en","readTime":3,"excerpt":"<p>Parsing and displaying Markdown files are one of the most important things in building a personal website, because all my...</p>"},{"slug":"2021-3-10-build-my-website-nextjs","title":"How To Build My Own Website (1) - Next.js","date":"2021-03-10T20:00:00+08:00","locale":"en","readTime":5,"excerpt":"<p>I had always dreamed of building my own website, to express myself, to keep memory of what I have done,...</p>"}]},"__N_SSG":true}