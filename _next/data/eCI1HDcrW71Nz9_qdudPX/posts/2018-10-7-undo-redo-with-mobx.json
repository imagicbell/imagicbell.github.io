{"pageProps":{"post":{"title":"Implement Undo/Redo With Mobx In React","date":"2018-10-07T19:00:00+08:00","slug":"2018-10-7-undo-redo-with-mobx","categories":["Front-End"],"readTime":3,"content":"<p>In one of my <a href=\"https://reactjs.org/\" rel=\"noopener noreferrer\" target=\"_blank\">React</a> project with <a href=\"https://threejs.org/\" rel=\"noopener noreferrer\" target=\"_blank\">three.js</a>, I chose <a href=\"https://mobx.js.org/index.html\" rel=\"noopener noreferrer\" target=\"_blank\">MobX</a> as my state management over <a href=\"https://redux.js.org/\" rel=\"noopener noreferrer\" target=\"_blank\">Redux</a>, mostly because I found it difficult to deal immutability with three.js. However, mutability brings difficulties in the history management. I spent much effort in solving this problem, as there is very few ready-to-use tools existed. Here is what I did. <a href=\"https://github.com/imagicbell/json-mobx\" rel=\"noopener noreferrer\" target=\"_blank\">Github project</a>.</p>\n<p>After some research, I learned that to enable time-travel, history states are needed to be recorded each time a change is made, and then re-apply the corresponding history state to current state. Here are 3 main problems:</p>\n<ol>\n<li>trigger when a change is made.</li>\n<li>record history state - serialization.</li>\n<li>re-apply history state - deserialization.</li>\n</ol>\n<h3 id=\"section-trigger\">Trigger</h3>\n<p>Fortunately, MobX provides a function <a href=\"https://mobx.js.org/refguide/autorun.html\" rel=\"noopener noreferrer\" target=\"_blank\">autorun</a> that enables a trigger when a change is made. But there is limitation:</p>\n<p><em><code>autorun</code> will only observe data that is used during the execution of the provided function.</em></p>\n<p>So in the function, I need to include all the data that needs to be recorded.</p>\n<p>How? </p>\n<p>Serialization.</p>\n<h3 id=\"section-serializationdeserialization\">Serialization/Deserialization</h3>\n<p>First I saw MobX has provided the <a href=\"https://mobx.js.org/refguide/tojson.html\" rel=\"noopener noreferrer\" target=\"_blank\">toJS</a> to recursively converts an (observable) object to a javascript <em>structure</em>. That's good. But it didn't work out in my application. Two reasons:</p>\n<ol>\n<li>It saves everything in the object, including methods, which is not needed. Only the observable properties are needed. </li>\n<li>After <code>toJS</code>, we got a new js object, which is not the MobX store object. To \"deserialization\", we need to deep copy the object to the MobX store object, otherwise the React components will not response. </li>\n</ol>\n<p>So I need to find a way to recursively serialize the observable properties of store objects, and recursively deserialze them while not chaning the store objects themselves.</p>\n<p>Thanks to the GitHub project <a href=\"https://github.com/danielearwicker/json-mobx\" rel=\"noopener noreferrer\" target=\"_blank\">json-mobx</a>, we got the solution!</p>\n<p>By decorating the <code>@json</code> to observable properties, it automatically gains a hidden <code>json</code> property. It is defined by a MobX <code>computed</code> so it only regenerates the JSON representation if anything changes.</p>\n<p>Just call <code>json.save</code> in <code>autorun</code> function to snapshot the observable data of MobX stores, and <code>json.load</code> when undo/redo happens to re-apply the history data.</p>\n<h4 id=\"section-how-to-add-json-to-threejs-defined-properties\">How to add <code>@json</code> to three.js defined properties?</h4>\n<p>MobX gives a way to add decoraters to properties of pre-defined structures. </p>\n<p><code>decorate(object, decorators)</code></p>\n<pre><code>decorate(THREE.Object3D, {\n  name: [json, observable],\n  parent: [json, observable],\n  children: [json, observable],\n  up: [json, observable],\n  position: [json, observable],\n  rotation: [json, observable],\n  scale: [json, observable],\n  visible: [json, observable],\n})\n\ndecorate(THREE.Vector3, {\n  x: [json, observable],\n  y: [json, observable],\n  z: [json, observable],\n})</code></pre>\n<h3 id=\"section-optimization\">Optimization</h3>\n<p>As MobX can have more than one stores. Each time a change happens, serializing all data of all stores seems to be a waste of storage. So I optimized the <code>json-mobx</code>'s undo/redo scheme. </p>\n<p><em>Only one store's data is serialzied and push to the history states when a change happens. Of course we only have one history management object, however, each element in its history state stack is not the history state of the root store(containing all the store objects), but the history state of one exact store. We keep an <code>id</code> for connecting each store with its history states.</em></p>\n<p>This scheme results in a problem: the first history state.</p>\n<p>Each time we add a store to the history management, we register an <code>autorun</code> on that store object to observe any changes. The <code>autorun</code> will trigger an initial call by MobX even though nothing is changed. Then we got an initial call for every store, which will results in separate history state in the undo stack, meaning that we will loose the initial state for some stores when undo is done. So we must have a history state for the initial state of all the stores. Here is what we did:</p>\n<pre><code class=\"javascript language-javascript\"> private observe = (state: any) =&gt; {\n    const newState = new HistoryState(json.save(state), this.getStateId(state));\n\n    // push first states for all stores\n    let firstStates = this.firstState.state as HistoryState[];\n    if (firstStates.length &lt; this.stateList.length &amp;&amp;\n        firstStates.findIndex(s =&gt; s.id === newState.id) &lt; 0) {\n      firstStates.push(newState);\n      return;\n    }\n\n    if (this.isLoadingState) {\n        this.isLoadingState = false;            \n    } else {\n        this.redoStack.length = 0;\n        this.undoStack.push(this.undoStack.length &gt; 0 ? this.currentState : this.firstState);\n    }\n\n    this.currentState = newState;\n  }</code></pre>\n<h3 id=\"section-conclusion\">Conclusion</h3>\n<p>So we got an optimized solution for the undo/redo with MobX. Each time a change happens, we snapshot the observable data for the corresponding store and push it to the undo stack. When undo/redo happens, we just retrieve the saved data from undo/redo stack and re-apply it to the corresponding store.</p>"},"postNav":{"previous":"/posts/2018-6-10-chain-animation-on-wheels","next":"/posts/2019-4-29-wechatmini"},"morePosts":[{"slug":"2021-3-14-build-my-website-style","title":"How To Build My Own Website (3) - Style","date":"2021-03-14T20:00:00+08:00","locale":"en","excerpt":"This article illustrates how I style my own website using Tailwindcss framework, make theme color configurable, and apply interactive animations.","readTime":2},{"slug":"2021-3-12-build-my-website-markdown","title":"How To Build My Own Website (2) - Markdown","date":"2021-03-12T20:00:00+08:00","locale":"en","readTime":3,"excerpt":"<p>Parsing and displaying Markdown files are one of the most important things in building a personal website, because all my...</p>"},{"slug":"2021-3-10-build-my-website-nextjs","title":"How To Build My Own Website (1) - Next.js","date":"2021-03-10T20:00:00+08:00","locale":"en","readTime":4,"excerpt":"<p>I had always dreamed of building my own website, to express myself, to keep memory of what I have done,...</p>"},{"slug":"2021-2-19-mock-requestanimationframe-in-jest","title":"Mock requestAnimationFrame in Jest","date":"2021-02-19T10:00:00+08:00","locale":"en","readTime":1,"excerpt":"<p>When I wrote test for my tiny rhythm game, I realized that all the browser based actions needed to be...</p>"}]},"__N_SSG":true}