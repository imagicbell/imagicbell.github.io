{"pageProps":{"post":{"title":"Google Blockly Reimplementation with Unity/C#(4)","date":"2017-10-31T20:00:00+08:00","slug":"2017-10-31-blockly-four","ogImage":"/blog/assets/img-blockly/Demo.png","categories":["Unity"],"readTime":8,"content":"<h2 id=\"section-contents\">Contents</h2>\n<ol>\n<li><a href=\"/posts/2017-10-11-blockly-one\" rel=\"noopener noreferrer\" target=\"_blank\">Introduction</a></li>\n<li><a href=\"/posts/2017-10-14-blockly-two\" rel=\"noopener noreferrer\" target=\"_blank\">Blockly Model</a></li>\n<li><a href=\"/posts/2017-10-22-blockly-three\" rel=\"noopener noreferrer\" target=\"_blank\">Code Generator, Interpreter and Runner</a></li>\n<li>UGUI Design</li>\n</ol>\n<p><br></p>\n<h2 id=\"section-ugui-design\">UGUI Design</h2>\n<p>在设计Blockly UI时，主要考虑解决以下几个问题：</p>\n<ol>\n<li><a id=\"q1\"></a>自动生成Block View，可以在Editor里预生成Prefab，也可以Runtime时动态生成GameObject。</li>\n<li><a id=\"q2\"></a>动态Layout，根据Block View的实际计算大小，以及View之间的相互连接，实现动态布局、缩放。</li>\n<li><a id=\"q3\"></a>动态Layout后，Block View底图的实时绘制。</li>\n<li><a id=\"q4\"></a>独立Blockly Model模块，采用观察者模式监听Model的变化。</li>\n<li><a id=\"q5\"></a>Block View最近连接的搜索。</li>\n<li><a id=\"q6\"></a>可重建Workspace，可复制Block View，可变形Block View。</li>\n</ol>\n<h3 id=\"section-hierarchy-of-views\">Hierarchy of Views</h3>\n<p>首先，需要设计一套View Hierarchy，既能符合Block Model的结构，表现Blocks之间的Connection，又能结合UGUI Transform Hierarchy，实现动态Layout计算。</p>\n<p>回顾<a href=\"/posts/2017-10-14-blockly-two#block\" rel=\"noopener noreferrer\" target=\"_blank\">讲解Block Model的章节</a>中关于Block Hierarchy的介绍，可知Block包括Connections、Inputs，而Inputs包括Fields、Connections，Connections可以连接其他Blocks，这些元素均需在UI上体现出来。在此基础上，我们还增加了一个LineGroup，因为某些Block View需要将Inputs分布在多行，LineGroup是用来包裹一行的Inputs。因此，最终的<a id=\"view-hierarchy\">View Hierarchy</a>如下：</p>\n<pre><code>hierarchy of view:\n\n- Block\n  - ConnectionOutput\n  - ConnectionPrev  \n  - ConnectionNext\n    - Block(Next)\n\n  - LineGroup\n    - Input\n      - Field \n      - Field \n      ...\n      - ConnectionInput\n        - Block(Input)\n    - Input\n      ...\n  - LineGroup\n    ...\n  ...\n- Block\n  ... </code></pre>\n<h4 id=\"section-抽象基类baseview\">抽象基类BaseView</h4>\n<p>Hierarchy中的每一个元素，都是一个View，因此我们抽象了基类<code>BaseView</code>，它继承<code>MonoBehaviour</code>，管理了：</p>\n<ul>\n<li>链式结构：Parent, Childs, Previous, Next。</li>\n<li>自下而上的迭代式Layout Update，<a href=\"#layout-example1\">详见这里</a>。</li>\n</ul>\n<h4 id=\"section-子类views类型\">子类Views类型</h4>\n<p>依据<a href=\"#view-hierarchy\">Hierarchy</a>，设计了6个基本的View类型：</p>\n<p><code>BlockView</code>, <code>ConnectionView</code>, <code>LineGroupView</code>, <code>InputView</code>,<code>FieldView</code>, <code>ConnectionInputView</code></p>\n<p>其中ConnectionInputView继承自ConnectionView，在Model中都体现为Connection，但在UI表现上ConnectionInputView是包裹输入Block的，而ConnectionView是挂载Next Block。</p>\n<p>基于这样的设计，可以很好的解决问题<a href=\"#q1\">1</a>、<a href=\"#q2\">2</a>、<a href=\"#q3\">3</a>。</p>\n<h3 id=\"section-auto-build-block-view\">Auto Build Block View</h3>\n<p>无论是Editor预生成Prefab，还是Runtime动态生成，Block View是依赖于Block Model来生成的。依照自上而下的顺序依次创建：</p>\n<p><em>Block</em> -&gt; <em>Connection, LineGroup</em> -&gt; <em>Input</em> -&gt; <em>Field</em> </p>\n<p>并且同时设置好链式关系，通过<code>MonoBehaviour</code>序列化保存下来。</p>\n<h3 id=\"section-dynamic-layout\">Dynamic Layout</h3>\n<p>为什么需要Dynamic Layout，它需要做什么？先看下面两个例子：</p>\n<p><a id=\"layout-example1\">例1</a></p>\n<p><img src=\"/blog/assets/img-blockly/Layout_1.png\" alt=\"\"> -&gt; <img src=\"/blog/assets/img-blockly/Layout_2.png\" alt=\"\"></p>\n<p><a id=\"layout-example2\">例2</a></p>\n<p><img src=\"/blog/assets/img-blockly/Layout_3.png\" alt=\"\"> -&gt; <img src=\"/blog/assets/img-blockly/Layout_4.png\" alt=\"\"></p>\n<p>可以看出：</p>\n<ol>\n<li>Block的Size会根据其自身Fields大小，以及其Child Blocks大小进行缩放；</li>\n<li>Block自身Fields的起始位置，以及Blocks相互之间的起始位置，都会根据缩放后的大小进行重新摆放；</li>\n</ol>\n<p>因此经过Dynamic Layout之后，布局更紧凑，更美观！那么如何实现的？</p>\n<p>UGUI有一套Layout机制，是依赖于Transform Hierarchy，在每一个生命周期的Update之后统一计算的，先后不可控，因此无法根据View的依赖关系按照正确的顺序计算。</p>\n<p>什么是正确的顺序？四个字概括：自下而上。依赖已经建立好的<a href=\"#view-hierarchy\">Hierarchy</a>，先从最小的元素Fields开始，计算起始位置和大小，然后遍历Next，依次叠加大小来计算起始位置，然后Parent，迭代下去，直到结束。代码大致如下：</p>\n<pre><code class=\"c# language-c#\">Vector2 newSize = CalculateSize();\nif (XY != startPos) XY = startPos;\nif (Size != newSize) Size = newSize;\n\nswitch (Type)\n{\n    case ViewType.Field:\n    case ViewType.Input:\n    case ViewType.ConnectionInput:\n    case ViewType.LineGroup:\n    {\n        if (m_Next == null)\n        {\n            //reach the last child, or no change in current hierarchy, update it's parent view\n            m_Parent.UpdateLayout(m_Parent.SiblingIndex == 0 ? m_Parent.HeaderXY : m_Parent.XY);\n        }\n        else\n        {\n            //update next\n            if (Type != ViewType.LineGroup)\n            {\n                // same line\n                startPos.x += Size.x + BlockViewSettings.Get().ContentSpace.x;\n            }\n            else\n            {\n                // start a new line\n                startPos.y -= Size.y + BlockViewSettings.Get().ContentSpace.y;\n            }\n\n            BaseView topmostChild = m_Next.GetTopmostChild();\n            if (topmostChild != m_Next)\n            {\n                //need to update from its topmost child\n                m_Next.XY = startPos;\n                topmostChild.UpdateLayout(topmostChild.HeaderXY);\n            }\n            else\n            {\n                m_Next.UpdateLayout(startPos);\n            }\n        }\n        break;\n    }\n    case ViewType.Connection:\n    case ViewType.Block:\n    {\n        //no need to update its m_Next, as it is handled by Unity's Transform autolayout \n        //update its parent directly\n        if (m_Parent != null)\n        {\n            m_Parent.UpdateLayout(m_Parent.SiblingIndex == 0 ? m_Parent.HeaderXY : m_Parent.XY);\n        }\n        break;\n    }\n}</code></pre>\n<h3 id=\"section-custom-background-draw\">Custom Background Draw</h3>\n<p>动态Layout之后，带来的就是底图的实时绘制，当然采用了九宫格的方式，但是简单的九宫格缩放不能满足需求，看这个：</p>\n<p><img src=\"/blog/assets/img-blockly/Layout_5.png\" alt=\"\"></p>\n<p>而这里只用了一张原图：</p>\n<p><img src=\"/blog/assets/img-blockly/Layout_6.png\" alt=\"\"></p>\n<p>当然颜色是自定义设置的，通过UGUI Image面板设置。</p>\n<p>其实方法很简单，参照UGUI中绘制<code>Image</code>的方法，重载<code>OnPopulateMesh(VertexHelper)</code>方法，按照九宫格的方式设置好顶点、uv，即可：</p>\n<p><img src=\"/blog/assets/img-blockly/Layout_7.png\" alt=\"\">  -&gt;  <img src=\"/blog/assets/img-blockly/Layout_8.png\" alt=\"\"></p>\n<p>上图用圆点标记的，是由外部Layout计算好之后的每一个LineGroup的顶点min, max。分析与代码详见<a href=\"/posts/2017-12-1-unity-image-manipulation\" rel=\"noopener noreferrer\" target=\"_blank\">这篇</a>。</p>\n<p>动态绘制底图还有一个好处是：不需要拼接图片，减少了资源量，并且避免了Draw Call的增加。</p>\n<h3 id=\"section-observer-pattern\">Observer Pattern</h3>\n<p>因为一开始设计的初衷是Model模块完全独立于另外两个模块Interpreter、UI，如果想要移植，完全可以以Model为核心，重新设计这两个模块。因此需要实现Model模块的完全解耦，而Google Blockly Web版是将UI与Model耦合在一起了，也许并不需要考虑移植。</p>\n<p>观察者模式，是实现UI与Model之间通信的最好方式，Model是事件的发布者，是任何变化、计算的核心，而UI是监听者，监听Model的变化更新表现，以及将用户输入转化为通知Model变化的信号。</p>\n<p>这是个经典的设计模式，在此不再赘述。</p>\n<h3 id=\"section-binary-search-nearest\">Binary Search Nearest</h3>\n<p>搜索最近连接，如果全局遍历所有的Connection Point，时间复杂度为<em>O(n)</em>，并且需要计算距离进行比对，无疑是一项耗cpu的操作。所幸的是Google Blockly提供了一套算法方案，二分搜索法。</p>\n<p>二分搜索法的前提是，有序序列，因此需要对Workspace中的所有Connection Point进行排列。做法是：</p>\n<ol>\n<li>基于Point的<code>y</code>坐标，维护一个有序的Connection Point Map。</li>\n<li>每当Block改变时（增、删、移动），将其Connection Point插入到Map中合适的位置，这个位置也是通过二分搜索法查找，只考虑<code>y</code>坐标。</li>\n</ol>\n<p>当要搜索Connection时，先通过<code>y</code>坐标找到其在Map中的位置，然后向两边查找。时间复杂度为<em>O(logn)</em>。</p>\n<p>当要搜索最近Connection时，也是先通过<code>y</code>坐标找到其在Map中的位置，然后向两边通过比对距离来查找，也考虑Connection的兼容性（例如：数学运算符两边只允许数字输入）。时间复杂度为<em>O(logn)</em>，并且也平均减少了计算量。</p>\n<h3 id=\"section-manipulate-views\">Manipulate Views</h3>\n<p>基于以上，操作Block View就变得很方便，因为自动化，动态，并且极大程度的优化了性能。</p>\n<h4 id=\"section-重建workspace\">重建Workspace</h4>\n<p>Model层可以将Workspace保存为Xml文件，Xml文件可以再重建Workspace（见<a href=\"/posts/2017-10-14-blockly-two#workspace_xml\" rel=\"noopener noreferrer\" target=\"_blank\">前文</a>）。通过Workspace中Block Models，可以动态创建Block Views，并依据Connections，以及顶层Blocks的位置，实现自动Layout。</p>\n<h4 id=\"section-复制block-view\">复制Block View</h4>\n<p>Workspace可以保存为Xml文件，当然是基于Block可以保存为一个Xml Node，因此复制Block可以通过将原Block保存为Xml Node，然后从Xml Node重建一个新的Block，再通过Block动态创建Block View。</p>\n<h4 id=\"section-变形block-view\">变形Block View</h4>\n<p>Block具有<a href=\"/posts/2017-10-14-blockly-two#section-mutation特性\" rel=\"noopener noreferrer\" target=\"_blank\">Mutation特性</a>，可以动态修改Block结构，因此动态生成Block View的功能为此提供了便利，可以动态增删Input Views。</p>\n<p>UI部分还有很多可以优化，暂时先介绍这么多。当然如果有更好的设计方案，也欢迎指出，互相学习～</p>"},"postNav":{"previous":"/posts/2017-10-30-nested-ienumerator","next":"/posts/2017-11-8-unity-script-manipulation"},"morePosts":[{"slug":"2018-6-10-chain-animation-on-wheels","title":"Automatic Chain's Animation On wheel Models","date":"2018-06-10T16:00:00+08:00","locale":"en","readTime":3,"excerpt":"<p>In last blog, I introduced the construction of the chains on wheels. This blog will tell the animation calculations. The...</p>"},{"slug":"2018-6-7-auto-draw-chain-on-wheels","title":"Automatic Chain's Construction On wheel Models","date":"2018-06-07T16:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-auto-draw-chain/3.jpg","readTime":2,"excerpt":"<p>Rencently I did have fun with a project which I'd like to share. It is to construct a chain automatically...</p>"},{"slug":"2018-3-31-thread-in-unity","title":"Use Thread In Unity","date":"2018-03-31T13:00:00+08:00","locale":"en","readTime":2,"excerpt":"<p>It's been a long time since my last blog, as I've recently spent plenty of time to save a dying...</p>"},{"slug":"2018-1-20-orthographic-camera-computing","title":"Restrict Object In Specified Screen Area Using Orthographic Camera","date":"2018-01-20T15:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-orthographic-camera/1.JPG","readTime":3,"excerpt":"<p>I’ve encountered a problem to adjust the position of orthographic camera for restricting 3D objects in the specified rectangle area...</p>"}]},"__N_SSG":true}