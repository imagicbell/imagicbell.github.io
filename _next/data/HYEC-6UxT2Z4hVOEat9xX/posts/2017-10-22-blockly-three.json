{"pageProps":{"post":{"title":"Google Blockly Reimplementation with Unity/C#(3)","date":"2017-10-22T16:00:00+08:00","slug":"2017-10-22-blockly-three","ogImage":"/blog/assets/img-blockly/Demo.png","categories":["Unity"],"readTime":5,"content":"<h2 id=\"section-contents\">Contents</h2>\n<ol>\n<li><a href=\"/posts/2017-10-11-blockly-one\" rel=\"noopener noreferrer\" target=\"_blank\">Introduction</a></li>\n<li><a href=\"/posts/2017-10-14-blockly-two\" rel=\"noopener noreferrer\" target=\"_blank\">Blockly Model</a></li>\n<li>Code Generator, Interpreter and Runner</li>\n<li><a href=\"/posts/2017-10-31-blockly-four\" rel=\"noopener noreferrer\" target=\"_blank\">UGUI Design</a></li>\n</ol>\n<p>For English:</p>\n<ol>\n<li><a href=\"/posts/2021-6-10-ublockly-introduction\" rel=\"noopener noreferrer\" target=\"_blank\">Introduction</a></li>\n<li><a href=\"/posts/2021-6-11-ublockly-model\" rel=\"noopener noreferrer\" target=\"_blank\">Blockly Model</a></li>\n<li><a href=\"/posts/2021-6-12-ublockly-interpreter-runner\" rel=\"noopener noreferrer\" target=\"_blank\">Code Interpreter and Runner</a></li>\n<li><a href=\"/posts/2021-6-13-ublockly-ugui\" rel=\"noopener noreferrer\" target=\"_blank\">UGUI Design</a></li>\n</ol>\n<p><br></p>\n<h2 id=\"section-code-generator-interpreter-and-runner\">Code Generator, Interpreter and Runner</h2>\n<p>对于像Google Blockly一样使用动态语言，那么<strong>Generator</strong>就足够了。我们在Unity中支持了Lua，但是考虑到Lua对Unity特性使用的局限性，以及性能问题，我们决定提供一套<strong>C# Interpreter&amp;Runner</strong>的解决方案。</p>\n<h3 id=\"section-generator\">Generator</h3>\n<p>Generator是将Block翻译成动态脚本的一套解决方案。根据Block Model的属性、状态、连接（见<a href=\"/posts/2017-10-14-blockly-two\" rel=\"noopener noreferrer\" target=\"_blank\">Block Model详解</a>），将Block翻译成对应的代码。</p>\n<p>为一个Workspace生成代码时，首先从Top block开始调用对应的代码生成方法，如遇到有其他block作为该block的输入，则嵌套调用输入block的代码生成方法，并处理返回的赋值。完成后继续调用next block的代码生成方法，直到最后。</p>\n<p>经过Generator处理后，Workspace被翻译成了一串Lua脚本的字符串，在Unity中使用<a href=\"https://github.com/topameng/tolua\" rel=\"noopener noreferrer\" target=\"_blank\">uLua</a>执行即可。</p>\n<h4 id=\"section-naming机制\">Naming机制</h4>\n<p>为了防止命名冲突，以及错误使用语言的关键词(keyword)，维护了一个Naming机制。</p>\n<ol>\n<li>加后缀：分别在变量名、函数名后加指定的后缀，避免冲突及关键词使用；</li>\n<li>加数字：在相同命名后加数字区分，避免重命名；</li>\n</ol>\n<h3 id=\"section-interpreter\">Interpreter</h3>\n<p>因为C#是静态语言，不能像Lua, JavaScript一样动态执行生成代码，因此需要将Block解释成C#的执行方法，我们称之为Block的Interpreter。相应的，也是通过Block Model的属性、状态、连接来进行解释的。</p>\n<h4 id=\"section-ienumerator的使用\">IEnumerator的使用</h4>\n<p>重点介绍下，我在实现Interpreter时使用的一个C#特性：IEnumerator。为什么要用？原因主要有两点：</p>\n<ol>\n<li>Block执行的过程性，不限于一帧；</li>\n<li>Blocks之间的连接性，需要解释方法可重入。</li>\n</ol>\n<p>以下是部分摘自for-loop block的解释代码：</p>\n<pre><code class=\"c# language-c#\">protected override IEnumerator Execute(Block block)\n{\n    int repeats = int.Parse(block.GetFieldValue(\"TIMES\"));\n    for (int i = 0; i &lt; repeats; i++)\n    {\n        yield return CSharp.Interpreter.StatementRun(block, \"DO\");\n    }\n}</code></pre>\n<p>其中展示了围绕IEnumerator使用设计的三个方面：</p>\n<ol>\n<li><p>Block的解释方法返回IEnumerator，供嵌套调用，实现可重入。</p></li>\n<li><p>Block的解释方法是类方法，因为需要保存数据、状态，也便于复杂Block解释程序的扩展。</p></li>\n<li><p>嵌套调用需要返回执行结果数据的Block的解释方法时，使用了<code>CustomEnumerator</code>类，它继承自IEnumerator，并且可以携带数据。</p></li>\n</ol>\n<pre><code class=\"c# language-c#\">   public class CustomEnumerator : IEnumerator\n   {\n       private IEnumerator mItor;\n\n       public Cmdtor Cmdtor { get; set; }\n       public DataStruct Data { get { return Cmdtor.Data; } }\n\n       public CustomEnumerator(IEnumerator itor)\n       {\n           mItor = itor;\n       }\n\n       public bool MoveNext()\n       {\n           return mItor.MoveNext();\n       }\n\n       public void Reset()\n       {\n           mItor = null;\n       }\n\n       public object Current\n       {\n           get { return mItor.Current; }\n       }\n   }</code></pre>\n<p>以上for-loop block的解释代码中，当<code>TIMES</code>是另一个Block的输出时，可以通过<code>CustomEnumerator</code>来异步获取：</p>\n<pre><code class=\"c# language-c#\">   protected override IEnumerator Execute(Block block)\n   {\n       CustomEnumerator ctor = CSharp.Interpreter.ValueReturn(block, \"TIMES\", new DataStruct(0));\n       yield return ctor;\n       DataStruct repeatData = ctor.Data;\n       int repeats = (int) repeatData.NumberValue.Value;\n       //...\n   }</code></pre>\n<h4 id=\"section-data-in-blockly\">Data In Blockly</h4>\n<p>因为JavaScript动态类型的特性，并且基本类型只包括：Boolean, Number, String, Object，因此Google Blockly在生成代码时不需要考虑数据类型，这一切交给JavaScript的runtime interpreter就行。同理Lua。</p>\n<p>但是C#是静态类型并且强类型的，因此我们在解释Block时需要对数据类型加一层处理，和一点约束。</p>\n<p>我们为Blockly定义了5个数据类型： <code>Undefined</code>,  <code>Boolean</code>, <code>Number</code>, <code>String</code>, <code>List</code>，并且定义了<code>DataStruct</code>用来包裹数据。</p>\n<h5 id=\"section-undefined\">Undefined</h5>\n<p>表示未定义数据，DataStruct的默认类型。</p>\n<h5 id=\"section-boolean\">Boolean</h5>\n<p>C#的原型bool类型，作为逻辑运算true、false的基本类型。</p>\n<h5 id=\"section-number\">Number</h5>\n<p>为了统一数字类型，我们定义了一个Number类，将传入的原数据（boolean, int, float, double, string…）通过强转或解释的方式，存储为float型，并基于此重载了基本数学运算等方法。</p>\n<h5 id=\"section-string\">String</h5>\n<p>C#的原型string类型，用作表示字符串，字符也将被转换为该类型。</p>\n<h5 id=\"section-list\">List</h5>\n<p>C#的ArrayList，之所以用ArrayList，是因为它允许元素类型的多样化。但是在对<code>List</code>做数学运算、字符拼接等操作时，会相应的先将元素转换为统一类型。</p>\n<h5 id=\"section-datastruct\">DataStruct</h5>\n<p>作为包裹数据的载体，包含数据本身，和数据类型，用作解释Block时的统一数据存储类型，实现变量的动态赋值，可以看作是<code>var</code>.</p>\n<p>Blockly中的变量在一个Workspace中是全局的，因此在解释Block时需要管理一个相对Workspace的全局数据容器，通过key:value（变量名：数据）的方式存储，并提供增删改查。</p>\n<h3 id=\"section-runner\">Runner</h3>\n<p>将Blocks分别解释成对应的C#的执行方法后，需要一个Runner来运行这些方法，以及控制Start, Pause, Resume, Stop等状态。因为Block的解释方法返回的是IEnumerator，因此利用Unity的Coroutine，我们可以简单的实现部分需求。但是有两个问题:</p>\n<ol>\n<li>无法实现Pause, Resume的功能。</li>\n<li>直接使用StartCoroutine(IEnumerator)，在遇到嵌套IEnumerator调用时至少需要花费一帧，即使嵌套方法在实际执行中没有执行到<code>yield return</code>。</li>\n</ol>\n<p>因此，我们参考Unity Coroutine的实现原理，做了适当的调整，模拟了一套满足以上需求的Runner解决方案。具体方案解析，详见<a href=\"/posts/2017-10-30-nested-ienumerator\" rel=\"noopener noreferrer\" target=\"_blank\">这篇</a>。</p>\n<p>当然开发者在扩展Blocks时，只需按照既定的方式提供Block的解释方法即可。如果有更好的设计，也欢迎指出，互相学习～</p>"},"postNav":{"previous":"/posts/2017-10-19-travelling-nz","next":"/posts/2017-10-30-nested-ienumerator"},"morePosts":[{"slug":"2021-6-13-ublockly-ugui","title":"The UGUI Design of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-13T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":5,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-12-ublockly-interpreter-runner","title":"The Interpreter and Runner of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-12T11:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":6,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-11-ublockly-model","title":"The Blockly Model of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-11T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":4,"excerpt":"<p>For Chinese:...</p>"},{"slug":"2021-6-10-ublockly-introduction","title":"Introduction of uBlockly - Reimplementation of Google Blockly in Unity","date":"2021-06-10T20:00:00+08:00","locale":"en","ogImage":"/blog/assets/img-blockly/Demo.png","readTime":1,"excerpt":"<p>For Chinese:...</p>"}]},"__N_SSG":true}